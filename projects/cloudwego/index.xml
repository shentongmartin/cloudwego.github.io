<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CloudWeGo – CloudWeGo</title><link>https://www.cloudwego.io/projects/cloudwego/</link><description>Recent content on CloudWeGo</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 21 Feb 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://www.cloudwego.io/projects/cloudwego/index.xml" rel="self" type="application/rss+xml"/><item><title>Blog: Delving Deeper: Enriching Microservices with Golang with CloudWeGo</title><link>https://www.cloudwego.io/blog/2024/02/21/delving-deeper-enriching-microservices-with-golang-with-cloudwego/</link><pubDate>Wed, 21 Feb 2024 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/blog/2024/02/21/delving-deeper-enriching-microservices-with-golang-with-cloudwego/</guid><description>
&lt;p>What if there existed an RPC framework that provided not only high performance and extensibility but also a robust suite of features and a thriving community support?&lt;/p>
&lt;p>CloudWeGo, a high-performance extensible Golang and Rust RPC framework originally developed and open-sourced by &lt;a href="https://opensource.bytedance.com">ByteDance&lt;/a>, has caught my eye as it fits the bill perfectly.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Delving_Deeper_Enriching_Microservices_with_Golang_and_Rust_with_CloudWeGo/1.jpeg" alt="Image">&lt;/p>
&lt;h2 id="cloudwego-vs-other-rpc-frameworks">CloudWeGo VS Other RPC Frameworks&lt;/h2>
&lt;p>While &lt;a href="https://grpc.io">gRPC&lt;/a> and &lt;a href="https://thrift.apache.org">Apache Thrift&lt;/a> have served the microservice architecture well, &lt;a href="https://www.cloudwego.io">CloudWeGo&lt;/a>&amp;rsquo;s advanced features and performance metrics set it apart as a promising open source solution for the future.&lt;/p>
&lt;p>Built for the modern development landscape by embracing both &lt;a href="https://go.dev">Golang&lt;/a> and &lt;a href="https://www.rust-lang.org">Rust&lt;/a>, CloudWeGo delivers advanced features and excellent performance metrics. As proof of its performance, benchmark tests have shown that &lt;a href="https://github.com/cloudwego/kitex-benchmark">Kitex surpasses gRPC by over 4 times in terms of QPS and latency, with a throughput increased by 51% - 70%&lt;/a> in terms of QPS (Queries Per Second) and latency.&lt;/p>
&lt;p>This equips developers with a tool that doesn&amp;rsquo;t just meet but decidedly surpasses the performance requirements of modern microservices. Let&amp;rsquo;s delve into some specific use cases to understand CloudWeGo&amp;rsquo;s potential.&lt;/p>
&lt;h3 id="bookinfo-a-tale-of-traffic-handling">Bookinfo: A Tale of Traffic Handling&lt;/h3>
&lt;p>Consider the case of Bookinfo, a sample application provided by &lt;a href="https://istio.io">Istio&lt;/a>, rewritten using CloudWeGo&amp;rsquo;s &lt;a href="https://www.cloudwego.io/docs/kitex/">Kitex&lt;/a> for superior performance and extensibility.&lt;/p>
&lt;p>This use case is illustrative of how traffic-heavy services can significantly benefit from CloudWeGo&amp;rsquo;s performance promise. This integration also demonstrates how CloudWeGo stands above traditional Istio service mesh when it comes to traffic handling and performance.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Delving_Deeper_Enriching_Microservices_with_Golang_and_Rust_with_CloudWeGo/2.jpeg" alt="Image">&lt;/p>
&lt;p>With Kitex and &lt;a href="https://www.cloudwego.io/docs/hertz/">Hertz&lt;/a> handling traffic redirection, the Bookinfo project can manage high traffic volumes efficiently, ensuring swift responses and a better user experience.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">import&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4e9a06">&amp;#34;github.com/cloudwego/kitex/server&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">main&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">svr&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">echo&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">NewServer&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87">new&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">EchoImpl&lt;/span>&lt;span style="color:#000;font-weight:bold">),&lt;/span> &lt;span style="color:#000">server&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">WithName&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;echo&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">listener&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">_&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">net&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Listen&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;tcp&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;:8888&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">svr&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Serve&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">listener&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above code snippet is a simplified example of how the Bookinfo project can be rewritten using Kitex for better performance.&lt;/p>
&lt;h3 id="easy-note-the-magic-of-simplicity">Easy Note: The Magic of Simplicity&lt;/h3>
&lt;p>CloudWeGo&amp;rsquo;s commitment to simplifying complex tasks shines in its application to the Easy Note project. It leverages CloudWeGo to implement a full-process traffic lane. The note-taking platform needs to be responsive and efficient, a need fulfilled by CloudWeGo&amp;rsquo;s high-performance networking library, &lt;a href="https://www.cloudwego.io/docs/netpoll/">Netpoll&lt;/a>.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Delving_Deeper_Enriching_Microservices_with_Golang_and_Rust_with_CloudWeGo/3.jpeg" alt="Image">&lt;/p>
&lt;p>The integration of CloudWeGo has elevated the Easy Note application to compete effectively with other note-taking platforms, proving how simplicity can indeed lead to power.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">import&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4e9a06">&amp;#34;github.com/cloudwego/kitex/server&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">RPCService&lt;/span> &lt;span style="color:#204a87;font-weight:bold">struct&lt;/span>&lt;span style="color:#000;font-weight:bold">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">s&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">RPCService&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">Handle&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">req&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">Request&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">Response&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">resp&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">Response&lt;/span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#000">Message&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;Echo &amp;#34;&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#000">req&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Message&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">resp&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">main&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">rpcHandler&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">RPCService&lt;/span>&lt;span style="color:#000;font-weight:bold">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">svr&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">server&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">NewServer&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">rpcHandler&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">listener&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">_&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">net&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Listen&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;tcp&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;:8888&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">svr&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Serve&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">listener&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The snippet above gives a glimpse of how CloudWeGo helps to enhance the efficiency of the Easy Note application.&lt;/p>
&lt;h3 id="book-shop-e-commerce-made-easy">Book Shop: E-Commerce Made Easy&lt;/h3>
&lt;p>In the bustling e-commerce landscape, Book Shop stands as a testament to CloudWeGo&amp;rsquo;s capacity for seamless integration. Integrating middleware like &lt;a href="https://www.elastic.co/elasticsearch">Elasticsearch&lt;/a> and &lt;a href="https://redis.io">Redis&lt;/a> into a Kitex project to build a solid e-commerce system that rivals more complex platforms.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Delving_Deeper_Enriching_Microservices_with_Golang_and_Rust_with_CloudWeGo/4.jpeg" alt="Image">&lt;/p>
&lt;p>CloudWeGo&amp;rsquo;s ability to effectively integrate with popular technologies like Elasticsearch and Redis ensures that businesses need not compromise on choosing an open-source RPC framework.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">import&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4e9a06">&amp;#34;github.com/cloudwego/kitex/server&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">ItemService&lt;/span> &lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000;font-weight:bold">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">s&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">ItemService&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">AddItem&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">item&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">Item&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Add to Elasticsearch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Add to Redis&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Return error if any&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">main&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">itemHandler&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">ItemService&lt;/span>&lt;span style="color:#000;font-weight:bold">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">svr&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">server&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">NewServer&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">itemHandler&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">listener&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">_&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">net&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Listen&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;tcp&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;:8888&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">svr&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Serve&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">listener&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above snippet is a basic representation of how the Book Shop e-commerce system operates with CloudWeGo, Elasticsearch, and Redis.&lt;/p>
&lt;h3 id="freecar-driving-innovation">FreeCar: Driving Innovation&lt;/h3>
&lt;p>The FreeCar project is an excellent illustration of how CloudWeGo can revamp the operations in a time-sharing car rental system, posing a strong alternative to existing ride-hailing applications.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Delving_Deeper_Enriching_Microservices_with_Golang_and_Rust_with_CloudWeGo/5.jpeg" alt="Image">&lt;/p>
&lt;p>This real-world implementation demonstrates how CloudWeGo&amp;rsquo;s robust features can optimize operations, fostering efficiency and scalability in industries beyond tech.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">import&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4e9a06">&amp;#34;github.com/cloudwego/kitex/server&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">CarService&lt;/span> &lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000;font-weight:bold">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">s&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">CarService&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">BookRide&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">rideRequest&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">RideRequest&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">RideConfirmation&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Business logic to handle ride booking&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Return confirmation or error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">main&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">rideHandler&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">CarService&lt;/span>&lt;span style="color:#000;font-weight:bold">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">svr&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">server&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">NewServer&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">rideHandler&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">listener&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">_&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">net&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Listen&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;tcp&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;:8888&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">svr&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Serve&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">listener&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above snippet is a simplified representation of how FreeCar utilizes CloudWeGo.&lt;/p>
&lt;h2 id="what-draws-me-to-cloudwego">What Draws Me to CloudWeGo?&lt;/h2>
&lt;p>As I venture further into the landscape of alternative RPC frameworks, and explore the CloudWeGo project, several factors stand out:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Performance&lt;/strong>: In the world of microservices, performance could mean the difference between success and failure. CloudWeGo shines when it comes to performance, with QPS and latency scores that leave other RPC frameworks trailing.&lt;/li>
&lt;li>&lt;strong>Extensibility&lt;/strong>: As a developer, what you&amp;rsquo;ll appreciate most about Kitex is its promise of extensibility, allowing projects to swiftly adapt to growing demands and complexities.&lt;/li>
&lt;li>&lt;strong>Robustness&lt;/strong>: The rich feature set of CloudWeGo, including support for multiple message protocols, transport protocols, load balancing, circuit breakers, and rate limiting, offers an all-inclusive solution for designing and managing microservices.&lt;/li>
&lt;li>&lt;strong>Community Support&lt;/strong>: The fact that CloudWeGo is backed by ByteDance assures me of strong community support. The wealth of resources and discussions available can solve common issues and support continuous learning.&lt;/li>
&lt;li>&lt;strong>Real-world Applications&lt;/strong>: Practical applications in diverse projects demonstrate CloudWeGo’s versatility and scalability, affirming my trust in its effectiveness.&lt;/li>
&lt;/ul>
&lt;h1 id="embracing-the-future-of-microservices">Embracing the Future of Microservices&lt;/h1>
&lt;p>With each use case, CloudWeGo&amp;rsquo;s potential becomes increasingly clear. Developers can now build high-performing, extensible, and robust applications, harnessing the true essence of microservices - no matter if they prefer working with Golang or Rust.&lt;/p>
&lt;p>If you&amp;rsquo;re considering a new tool for your microservice architecture, especially if you are interested in Rust, &lt;a href="https://www.cloudwego.io/docs/">give CloudWeGo a try&lt;/a>. The future of microservices awaits you.&lt;/p></description></item><item><title>Blog: Enhancing Performance in Microservice Architecture with Kitex</title><link>https://www.cloudwego.io/blog/2024/01/29/enhancing-performance-in-microservice-architecture-with-kitex/</link><pubDate>Mon, 29 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/blog/2024/01/29/enhancing-performance-in-microservice-architecture-with-kitex/</guid><description>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/1.jpeg" alt="Image">&lt;/p>
&lt;h1 id="kitex-enhancing-performance-in-microservice-architecture">Kitex: Enhancing Performance in Microservice Architecture&lt;/h1>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>The team at ByteDance initiated the creation of the Remote Procedure Call (RPC) framework, Kitex, alongside several related fundamental libraries in 2019. This endeavor originated from confronting functionality and performance challenges within our extensive microservice architecture. We also wanted to combine the knowledge and insights gathered from previous frameworks. This development project was officially released for open-source contribution on GitHub in 2021.&lt;/p>
&lt;p>From 2019 to 2023, our internal microservices have seen substantial growth. During this period, &lt;a href="https://www.cloudwego.io/docs/kitex/overview/">the Kitex framework&lt;/a> has undergone numerous cycles of optimization and testing to enhance its performance and efficiency. In this article, we share performance optimization techniques that we&amp;rsquo;ve systematically implemented over the past few years.&lt;/p>
&lt;h2 id="the-evolution-and-status-quo-of-kitex">The Evolution and Status Quo of Kitex&lt;/h2>
&lt;h3 id="understanding-the-need-for-an-rpc-framework">Understanding the Need for an RPC Framework&lt;/h3>
&lt;p>Although the Remote Procedure Call (RPC) framework has a long history, its wide-scale use as a crucial component aligns with the advent of microservice architecture. Therefore, it&amp;rsquo;s vital to revisit its historical developments and comprehend why an RPC framework is necessary.&lt;/p>
&lt;h4 id="background-monolithic-architecture-era">Background: Monolithic Architecture Era&lt;/h4>
&lt;p>In this era, system services exhibited the following features:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Distinct business logic was categorized via functions.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The performance pressure was on the database, prompting the evolution from manually distributed databases to an automated distributed structure.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>A typical business coding model during this period looked something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Go" data-lang="Go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">BuySomething&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">userId&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">itemId&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">user&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">GetUser&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">userId&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">sth&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">GetItem&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">itemId&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">GetUser&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">userId&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">db&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">users&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">GetUser&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">userId&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">GetItem&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">itemId&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">db&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">items&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">GetItem&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">itemId&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/2.jpeg" alt="Image">&lt;/p>
&lt;p>This style of coding is straightforward, especially once built on top of a well-structured design pattern, can make it straightforward to refactor and write unit tests. Many IT systems still operate using this architecture.&lt;/p>
&lt;p>However, as online businesses rapidly developed, we encountered the following limitations in some of the larger internet projects:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>There&amp;rsquo;s a limit to computational power: the maximum computing power of a single request is less than or equal to the total computational power of a single server divided by the number of requests processed simultaneously.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>There&amp;rsquo;s a constraint around developmental efficiency: the growth of the code repository, team size, and code complexity do not have a linear relationship. This makes maintenance incrementally more challenging as the business grows, resulting in a more complicated online implementations.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="the-shift-microservice-architecture-era">The Shift: Microservice Architecture Era&lt;/h4>
&lt;p>To overcome the issues inherent in the monolithic architecture, the IT community embarked on a journey into the era of microservice architecture. Here&amp;rsquo;s an example of typical code used in a microservice architecture:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Go" data-lang="Go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">BuySomething&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">userId&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">itemId&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">user&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">client&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">GetUser&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">userId&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// RPC call&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">sth&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">client&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">GetItem&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">itemId&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// RPC call&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/3.jpeg" alt="Image">&lt;/p>
&lt;p>RPCs (Remote Procedure Call) allows business systems to call remote services as though invoking local methods. This reduces the complexity of understanding business operations to its most fundamental form and minimizes changes in business coding habits during the transition from a monolithic architecture to a microservice architecture.&lt;/p>
&lt;h2 id="the-cost-and-path-of-optimizing-rpc-performance">The Cost and Path of Optimizing RPC Performance&lt;/h2>
&lt;p>Before the introduction of RPC, the sole overhead in the following code is merely a function call, an operation at the nanosecond level, not accounting for inline optimization.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Go" data-lang="Go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">client&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">response&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">response&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">server&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">request&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// function call&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">server&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">request&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">response&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">response&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Message&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">request&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Message&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Upon transitioning to an RPC call, the overhead directly elevates to the millisecond level, a latency difference of 10^6, which highlights the high cost of RPC and indicates considerable room for optimization.&lt;/p>
&lt;pre tabindex="0">&lt;code>func client() (response) {
response = client.RPCCall(request) // rpc call - network
}
func server(request) (response) {
response.Message = request.Message
}
&lt;/code>&lt;/pre>&lt;p>The complete process of an RPC call is outlined below, and we will elaborate on our performance optimization practices for each step in the sections to follow.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/4.jpeg" alt="Image">&lt;/p>
&lt;h2 id="why-develop-our-custom-rpc-framework">Why Develop Our Custom RPC Framework?&lt;/h2>
&lt;p>Before delving into performance practices, let&amp;rsquo;s talk about why we opted to develop a new RPC framework. There are numerous existing frameworks available, so why did we need a new one? Some of the primary reasons include:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Internally at our company, we primarily use the Thrift protocol for communication. Most mainstream Go frameworks do not support the Thrift protocol, and extending to support multiple protocols isn&amp;rsquo;t a straightforward task.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Recognizing our company&amp;rsquo;s extremely high performance requirements, we realized that deep optimization across the entire operation chain was essential. The vast scale and complexity of our microservices demanded a bespoke, highly customizable, and scalable framework that could provide such flexibility and meet our rigorous performance standards.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="how-does-kitex-compare-to-other-frameworks">How Does Kitex Compare to Other Frameworks?&lt;/h1>
&lt;p>Kitex supports both the Thrift and gRPC protocols. Considering the lack of Thrift-compatible frameworks in the Go ecosystem, we used the gRPC protocol for our comparative study with the grpc-go framework. Check out the results:&lt;/p>
&lt;p>&lt;strong>gRPC Unary Comparison:&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/5.jpeg" alt="Image">&lt;/p>
&lt;p>&lt;strong>gRPC Streaming Comparison:&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/6.jpeg" alt="Image">&lt;/p>
&lt;h1 id="performance-optimization-practices-within-the-kitex-framework">Performance Optimization Practices within the Kitex Framework&lt;/h1>
&lt;p>Many performance optimization strategies used in Kitex aren&amp;rsquo;t exclusive to Go; however, for the sake of convenience, we&amp;rsquo;re using Go in our examples. In the following sections, we&amp;rsquo;ll introduce different performance optimization practices applied in Kitex, following the process of a RPC call.&lt;/p>
&lt;h2 id="optimizing-encoding-and-decoding">Optimizing Encoding and Decoding&lt;/h2>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/7.jpeg" alt="Image">&lt;/p>
&lt;h3 id="common-challenges-with-encoding-and-decoding">Common Challenges with Encoding and Decoding&lt;/h3>
&lt;p>Using Protobuf as an example, we encounter the following problems associated with encoding decoding operations:&lt;/p>
&lt;p>&lt;strong>Computational Overhead:&lt;/strong>&lt;/p>
&lt;p>a. Additional information needs to be retrieved through runtime reflection.&lt;/p>
&lt;p>b. There&amp;rsquo;s a need to invoke multiple functions and create several small objects, which adds to the processing overhead.&lt;/p>
&lt;p>&lt;strong>Garbage Collection (GC) Overhead:&lt;/strong>&lt;/p>
&lt;p>Memory reuse is a significant challenge, which often leads to the overhead of garbage collection operations during the encoding and decoding operations.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/8.jpeg" alt="Image">&lt;/p>
&lt;h3 id="code-generation-optimization-introducing-fastthrift--fastpb">Code Generation Optimization: Introducing FastThrift &amp;amp; FastPB&lt;/h3>
&lt;p>We&amp;rsquo;ve introduced encoding and decoding capabilities to Kitex by generating a large volume of code for both Thrift and Protobuf protocols. Since generated code can optimize preset runtime information, we can avoid additional operations during runtime and achieve several benefits.&lt;/p>
&lt;p>&lt;strong>Memory Reuse and Size Pre-calculation&lt;/strong>&lt;/p>
&lt;p>During serialization, we can invoke &lt;code>Size()&lt;/code> at a minimal cost and use it to pre-allocate a fixed-size memory block.&lt;/p>
&lt;p>Go code example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Go" data-lang="Go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">User&lt;/span> &lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Id&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Name&lt;/span> &lt;span style="color:#204a87;font-weight:bold">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">x&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">User&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">Size&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">n&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">n&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">x&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">sizeField1&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">n&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">x&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">sizeField2&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">n&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// Framework Process&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">size&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">msg&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Size&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">data&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">Malloc&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">size&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// allocate memory&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">Encode&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">user&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">data&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// encoding user object directly into the allocated memory to save one time of copy&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">Send&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">data&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// send data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">Free&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">data&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// reuse the allocated memory at next Malloc&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Minimize Function Calls and Object Creation&lt;/strong>&lt;/p>
&lt;p>Reducing the costs of invoking functions and creating small objects can yield significant benefits. This approach is especially beneficial in a language like Go, which heavily utilizes garbage collection (GC).&lt;/p>
&lt;p>As depicted below, the underlying fastWriteField function gets inlined during compile-time. As a result, the serialization FastWrite function essentially conducts sequential writing into a fixed piece of memory. A similar approach applies to FastRead.&lt;/p>
&lt;p>Go code example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Go" data-lang="Go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">x&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">User&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">FastWrite&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span> &lt;span style="color:#000;font-weight:bold">[]&lt;/span>&lt;span style="color:#204a87;font-weight:bold">byte&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">offset&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">offset&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">x&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">fastWriteField1&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#000">offset&lt;/span>&lt;span style="color:#000;font-weight:bold">:])&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">offset&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">x&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">fastWriteField2&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#000">offset&lt;/span>&lt;span style="color:#000;font-weight:bold">:])&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">offset&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// inline&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">x&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">User&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">fastWriteField1&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span> &lt;span style="color:#000;font-weight:bold">[]&lt;/span>&lt;span style="color:#204a87;font-weight:bold">byte&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">offset&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">offset&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">fastpb&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">WriteInt32&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#000">offset&lt;/span>&lt;span style="color:#000;font-weight:bold">:],&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">x&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Id&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">offset&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// inline&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">x&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">User&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">fastWriteField2&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span> &lt;span style="color:#000;font-weight:bold">[]&lt;/span>&lt;span style="color:#204a87;font-weight:bold">byte&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">offset&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">offset&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">fastpb&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">WriteString&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#000">offset&lt;/span>&lt;span style="color:#000;font-weight:bold">:],&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">x&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Name&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">offset&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="optimization-results">Optimization Results&lt;/h3>
&lt;p>As a result of these optimizations, we managed to improve the optimization output from the previous contribution of 3.58% to a notable 0.98%.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/9.jpeg" alt="Image">&lt;/p>
&lt;h2 id="jit-substitution-for-code-generation-introducing-frugal-thrift">JIT Substitution for Code Generation: Introducing Frugal (Thrift)&lt;/h2>
&lt;p>After reaping gains from the hardcoded approach, we encountered the following feedback:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>The volume of the generated code increases linearly with the growth of fields.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The generated code depends on the user&amp;rsquo;s version of their respective Kitex command-line tool, which can lead to conflicts during collaborations with multiple contributors.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>The feedback encouraged us to consider if the previously generated code could be created automatically at runtime. The answer is &amp;lsquo;yes&amp;rsquo; - but it would require the adoption of Just-In-Time Compilation (JIT) as a method of code optimization.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/10.jpeg" alt="Image">&lt;/p>
&lt;h3 id="advantages-of-jit">Advantages of JIT&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>Registers utilization and deeper inlining: this improves the efficiency of function calls.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Core computational functions use fully optimized assembly code, which leads to improved performance.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="optimization-results-of-jit">Optimization Results of JIT&lt;/h3>
&lt;p>As a result of JIT optimization, we improved the optimization result from 3.58% to an impressive 0.78%.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/11.jpeg" alt="Image">&lt;/p>
&lt;h3 id="comparing-frugal-and-apache-thrift">Comparing Frugal and Apache Thrift&lt;/h3>
&lt;p>This section presents a performance comparison of Frugal and Apache Thrift in the context of encoding and decoding.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/12.jpeg" alt="Image">&lt;/p>
&lt;h2 id="optimizing-network-library">Optimizing Network Library&lt;/h2>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/13.jpeg" alt="Image">&lt;/p>
&lt;h3 id="native-go-net-challenges-in-rpc-scenarios">Native Go Net Challenges in RPC Scenarios&lt;/h3>
&lt;p>Native Go Net in RPC situations presents the following challenges:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Each connection corresponds to one coroutine - when there are numerous upstream and downstream instances, the sheer number of Goroutines can significantly influence performance. This is particularly detrimental for businesses with intensive instances.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>It is unable to automatically detect the connection&amp;rsquo;s shutdown state.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>When a struct undergoes NoCopy serialization, the output typically takes the form of a two-dimensional byte array. However, Go&amp;rsquo;s &lt;code>Write([]byte)&lt;/code> interface falls short as it does not support handling non-continuous memory data.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Despite being highly compatible, it&amp;rsquo;s provided by Go Runtime and not conducive or suitable for adding new features.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/14.jpeg" alt="Image">&lt;/p>
&lt;h4 id="go-coding-example">Go Coding Example&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Go" data-lang="Go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">name&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;Steve Jobs&amp;#34;&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 0xc000000020&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">req&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">Request&lt;/span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#000">Id&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87">int32&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">),&lt;/span> &lt;span style="color:#000">Name&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000">name&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// Encode to [][]byte&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">4&lt;/span> &lt;span style="color:#000">bytes&lt;/span>&lt;span style="color:#000;font-weight:bold">],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">10&lt;/span> &lt;span style="color:#000">bytes&lt;/span>&lt;span style="color:#000;font-weight:bold">],&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// no-copy encoding, 0xc000000020&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// Copy to []byte&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">buf&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">4&lt;/span> &lt;span style="color:#000">bytes&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">10&lt;/span> &lt;span style="color:#000">bytes&lt;/span>&lt;span style="color:#000;font-weight:bold">]&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// new address&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// Write([]byte)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">net&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Conn&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Write&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="netpoll-optimization-practices">Netpoll Optimization Practices&lt;/h3>
&lt;p>Here are the main areas we focused on for optimization:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Coroutine Optimization&lt;/strong>: As much as possible, coroutines are reused and the number of connections aren&amp;rsquo;t tied to the number of coroutines.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Buffer Layer&lt;/strong>: Netpoll supports zero-copy read and write, and it reuses memory to minimize GC overhead during encoding and decoding.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Customization for RPC Small Packets High Concurrency Scenarios&lt;/strong>: Includes coroutine scheduling optimization, TCP parameter tuning, and more.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Deep Customization for Internal Environments&lt;/strong>: Includes modifying the Go Runtime to improve scheduling priority and kernel support for batch system calls, among other things.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/15.jpeg" alt="Image">&lt;/p>
&lt;h2 id="communication-layer-optimization">Communication Layer Optimization&lt;/h2>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/16.jpeg" alt="Image">&lt;/p>
&lt;h3 id="intra-machine-communication-optimization-issues-with-communication-efficiency-under-service-mesh">Intra-Machine Communication Optimization: Issues with Communication Efficiency under Service Mesh&lt;/h3>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/17.jpeg" alt="Image">&lt;/p>
&lt;p>After introducing Service Mesh, the business process primarily communicates with another sidecar process on the same machine, which brings in an additional layer of delay.&lt;/p>
&lt;p>Traditional Service Mesh solutions commonly hijack iptables to facilitate traffic forwarding to the sidecar process. This could lead to substantial performance loss at all levels. Kitex has carried out several performance optimization attempts at the communication layer and has finally developed a systematic solution.&lt;/p>
&lt;h1 id="optimization-of-intra-machine-communication-uds-replaces-tcp">Optimization of Intra-machine Communication: UDS Replaces TCP&lt;/h1>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/18.jpeg" alt="Image">&lt;/p>
&lt;h2 id="performance-comparison-between-uds-and-tcp">Performance Comparison between UDS and TCP:&lt;/h2>
&lt;pre tabindex="0">&lt;code>======== IPC Benchmark - TCP ========
Type Conns Size Avg P50 P99
Client 10 4096 127μs 76μs 232μs
Client-R 10 4096 2μs 1μs 1μs
Client-W 10 4096 9μs 4μs 7μs
Server 10 4096 24μs 13μs 18μs
Server-R 10 4096 1μs 1μs 1μs
Server-W 10 4096 7μs 4μs 7μs
======== IPC Benchmark - UDS ========
Type Conns Size Avg P50 P99
Client 10 4096 118μs 75μs 205μs
Client-R 10 4096 3μs 2μs 3μs
Client-W 10 4096 4μs 1μs 2μs
Server 10 4096 24μs 11μs 16μs
Server-R 10 4096 4μs 2μs 3μs
Server-W 10 4096 3μs 1μs 2μs
&lt;/code>&lt;/pre>&lt;p>Our performance test indicates the following:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>UDS outperforms TCP in all measurements.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Nonetheless, the extent of improvement is not significant.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="optimization-of-intra-machine-communication-shmipc-replaces-uds">Optimization of Intra-Machine Communication: ShmIPC Replaces UDS&lt;/h1>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/19.jpeg" alt="Image">&lt;/p>
&lt;p>In pursuit of enhancing the efficiency of inter-process communication, we developed a communication mode based on shared memory. Shared memory communication throws in the complexity of managing the synchronization of various communication states across different processes.&lt;/p>
&lt;p>To tackle this, we utilized our communication protocol and retained &lt;strong>UDS&lt;/strong> as the event notification channel (IO Queue) and shared memory as the data transmission channel (Buffer).&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/20.jpeg" alt="Image">&lt;/p>
&lt;p>For a detailed technical understanding of shmipc, you can refer to our previously published article: &lt;a href="https://www.cloudwego.io/blog/2023/04/04/introducing-shmipc-a-high-performance-inter-process-communication-library/">Introducing Shmipc: A High Performance Inter-process Communication Library&lt;/a>.&lt;/p>
&lt;h2 id="performance-test">Performance Test:&lt;/h2>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/21.jpeg" alt="Image">&lt;/p>
&lt;h1 id="from-cross-machine-to-intra-machine-communication-a-pod-affinity-solution">From Cross-Machine to Intra-Machine Communication: A Pod Affinity Solution&lt;/h1>
&lt;p>Having previously optimized intra-machine communication, we found that it&amp;rsquo;s limited to the data plane communication between the service process and the Service Mesh.&lt;/p>
&lt;p>The peer service is possibly not hosted on the same machine. So, the question arises, how can we optimize cross-machine communication? One innovative approach we&amp;rsquo;re considering is converting cross-machine issues into intra-machine issues.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/22.jpeg" alt="Image">&lt;/p>
&lt;p>Achieving this in large-scale microservice communication calls for the cooperation of multiple architectural components. As such, we introduced the pod affinity solution to resolve this challenge:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Container Scheduling Layer Alteration: The container scheduling system will consider the relationship and instance situations of upstream and downstream services. It uses affinity scheduling to, as much as possible, assign the instances of upstream and downstream services to the same physical machine.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Traffic Scheduling Layer Alteration: The service control plane needs to identify which downstreams are connected to a certain upstream container. Bearing in mind the context of global load balancing, it calculates the dynamic weight of accessing downstream instances for each downstream instance, aiming to enable more traffic to facilitate intra-machine communication.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Framework Transformation: Extend custom support for the unique communication method of pod affinity. Based on the calculation results of the traffic scheduling layer, the request is dispatched to either the same machine instance or Mesh Proxy.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/23.jpeg" alt="Image">&lt;/p>
&lt;h1 id="microservice-online-tuning-practices">Microservice Online Tuning Practices&lt;/h1>
&lt;p>Apart from performance optimization at the framework level, the business logic itself is a significant contributor to the performance bottleneck. To combat this, we have accumulated several practical experiences and strategies.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/24.jpeg" alt="Image">&lt;/p>
&lt;h1 id="solving-latency-through-automated-gc-optimization">Solving Latency Through Automated GC Optimization&lt;/h1>
&lt;h2 id="challenges-with-gos-native-gc-strategy">Challenges with Go&amp;rsquo;s Native GC Strategy&lt;/h2>
&lt;p>Go&amp;rsquo;s Garbage Collection (GC) strategy was not specifically designed for microservice scenarios, and thus does not prioritize optimizing latency-sensitive businesses. However, RPC services often require low P99 latency.&lt;/p>
&lt;p>The essential principles of Go&amp;rsquo;s GC strategy are as follows:&lt;/p>
&lt;h3 id="gogc-principle">GOGC Principle:&lt;/h3>
&lt;p>The GOGC parameter sets a percentile value, defaulting to 100, to calculate the heap size required for the next GC trigger: &lt;code>NextGC = HeapSize + HeapSize * (GOGC / 100)&lt;/code>. This implies that under default settings, the heap size doubles after the last GC.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/25.jpeg" alt="Image">&lt;/p>
&lt;p>As an example, if a service&amp;rsquo;s active memory usage is 100MB, the GC is triggered every time the heap grows to 200MB, which may be unnecessary if this service has 4GB of memory.&lt;/p>
&lt;p>&lt;strong>Drawbacks:&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>In microservice environments, the service&amp;rsquo;s memory utilization rate is generally quite low, yet aggressive GC persists.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>For RPC scenarios, a sizable number of objects are inherently highly reusable. Performing frequent GC on these reusable objects degrades the reusability rate.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/26.jpeg" alt="Image">&lt;/p>
&lt;p>&lt;strong>Primary Requirement:&lt;/strong>&lt;/p>
&lt;p>Decrease the frequency of GC and enhance the reuse rate of resources in microservices, while maintaining safe levels of memory consumption.&lt;/p>
&lt;h2 id="gctuner-automated-gc-optimization-strategy">gctuner: Automated GC Optimization Strategy&lt;/h2>
&lt;p>Users can manipulate the desired aggressiveness of GC by setting a threshold, which could for example be set to &lt;code>memory_limit * 0.7&lt;/code>. If the memory used is below this value, GCPercent is maximized as much as possible.&lt;/p>
&lt;ul>
&lt;li>If memory utilization doesn&amp;rsquo;t reach the set threshold, the GOGC parameter is set to a larger value, whereas if it exceeds the limit, it is set to a smaller value.&lt;/li>
&lt;li>Regardless of the situation, GOGC is capped at a minimum of 50 and a maximum of 500.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Advantages:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>GC is delayed when memory utilization is low.&lt;/li>
&lt;li>It reverts to the native GC strategy when memory utilization is high.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Cautions:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>If other processes share the memory resources, ensuring a reserve of memory resources for these different processes is crucial.&lt;/li>
&lt;li>Services in which memory is likely to have excessively extreme peak values might not find this strategy beneficial.&lt;/li>
&lt;/ul>
&lt;p>gctuner is currently open-sourced &lt;a href="https://github.com/bytedance/gopkg/tree/develop/util/gctuner">on GitHub&lt;/a>.&lt;/p>
&lt;h1 id="concurrent-optimization">Concurrent Optimization&lt;/h1>
&lt;h2 id="what-is-the-real-cpu-utilization---the-container-deception">What Is the Real CPU Utilization? - The Container Deception&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">apiVersion&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">v1&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">kind&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Pod&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">spec&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">containers&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>- &lt;span style="color:#204a87;font-weight:bold">resources&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">limits&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">cpu&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#4e9a06">&amp;#34;4&amp;#34;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The rapid advancement of container technology has largely affected the development of microservices. Currently, the majority of microservices, including numerous databases across the industry, operate within container environments. For the purpose of this discussion, we&amp;rsquo;ll only touch upon mainstream containers based on cgroup technology.&lt;/p>
&lt;p>A standard business development model involves developers acquiring a 4-core CPU container on the container platform. Developers usually assume that their program can utilize up to 4 CPUs simultaneously, and adjust their program configuration based on this understanding.&lt;/p>
&lt;p>Upon deployment, if you check upon the container and verify with the &amp;rsquo;top&amp;rsquo; command, all indicators seemingly adhere to the 4-core standard:&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/27.jpeg" alt="Image">&lt;/p>
&lt;p>Even when using &lt;code>cat /proc/cpuinfo&lt;/code> for inspection, you&amp;rsquo;ll witness exactly 4 CPUs.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">processor&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">processor&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">processor&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">processor&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>However, these are merely illusions concocted by the container to ease your mental load off programming. The underlying reason for creating such an illusion is to ensure traditional Linux Debug tools function seamlessly within the container environment.&lt;/p>
&lt;p>Contrarily, container technology based on cgroups imposes limits only on &lt;strong>CPU time&lt;/strong>, not on the number of CPUs. Suppose you log into the machine to verify the CPU number each thread of the process is using. In that case, you might be taken aback to discover that the sum exceeds the CPU limit set for the container:&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/28.jpeg" alt="Image">&lt;/p>
&lt;p>When a container requests 4 CPU units, it means it can run for an equivalent of 4 CPU time within a computation cycle (typically 100ms). It doesn&amp;rsquo;t imply that it can only use 4 physical CPUs, nor that at least 4 CPUs can be simultaneously utilized by the program. If the usage time surpasses the CPU limit set for the container, all processes within the container are paused until the end of the computation period. This could lead to the program experiencing lagging issues (throttled).&lt;/p>
&lt;h2 id="is-faster-downstream-parallel-processing-always-better---concurrency-vs-timeout">Is Faster Downstream Parallel Processing Always Better? - Concurrency vs. Timeout&lt;/h2>
&lt;p>Knowing the upper bound for physical parallel computing in a program is considerably high, we can leverage this insight to increase or decrease the number of working threads (GOMAXPROCS) or adjust the degree of concurrency within the program.&lt;/p>
&lt;p>Let&amp;rsquo;s consider a calling scenario where the business sends requests to the same upstream with four concurrent processes. Each request upstream requires 50ms of processing time. Based on this, the downstream sets the timeout time to &lt;strong>100ms&lt;/strong>.&lt;/p>
&lt;p>Though this seems reasonable, if, at that time, the upstream had only two CPUs available to handle requests (which also have to manage other work or perform Garbage Collection activities), the third RPC request would likely time out.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/29.jpeg" alt="Image">&lt;/p>
&lt;p>However, simply reducing concurrency isn&amp;rsquo;t always the solution and it doesn&amp;rsquo;t benefit all cases.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/30.jpeg" alt="Image">&lt;/p>
&lt;p>If upstream&amp;rsquo;s computational resources are abundantly available, increasing concurrency could efficiently utilize the processing power upstream.&lt;/p>
&lt;h2 id="balancing-resource-utilization--reserving-computational-capacity-for-other-processes">Balancing Resource Utilization – Reserving Computational Capacity for Other Processes&lt;/h2>
&lt;p>If there are multiple processes within the container, it&amp;rsquo;s essential to reserve resources for these operations. This consideration is particularly crucial in scenarios like the deployment of a Service Mesh data plane, where the same container operates as a sidecar.&lt;/p>
&lt;p>If a downstream process utilizes the entirety of the time slice allocated within a computation cycle, it&amp;rsquo;s highly probable that it&amp;rsquo;ll face resource throttling when it&amp;rsquo;s the upstream process&amp;rsquo;s turn, which could subsequently affect the service’s latency.&lt;/p>
&lt;h2 id="optimizing-service-concurrency-degree">Optimizing Service Concurrency Degree&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Adjust the Number of Work Threads&lt;/strong>: For instance, the &lt;code>GOMAXPROCS&lt;/code> directive in Go allows us to modify the number of working threads.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Alter the Concurrency of Requests in the Code&lt;/strong>: It&amp;rsquo;s essential for businesses to iteratively test and evaluate the trade-off between the latency gains from increasing concurrency and the stability loss at peak levels to determine an optimal concurrency value.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Use Batch Interfaces&lt;/strong>: If the business scenario allows, replacing the current interface with a batch interface could be a more effective strategy.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="looking-into-the-future-of-optimization">Looking into the Future of Optimization&lt;/h1>
&lt;h2 id="the-final-frontier-kernel">The Final Frontier: Kernel&lt;/h2>
&lt;p>Currently the only area we haven&amp;rsquo;t explored for optimization is the Kernel.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Enhancing_Performance_in_Microservice_Architecture_with_Kitex/31.jpeg" alt="Image">&lt;/p>
&lt;p>In online business environments, we often observe that the communication overhead of RPC accounts for more than 20% of the total overhead for services heavy on I/O operations, even after optimizing RPC to the level of intra-machine communication.&lt;/p>
&lt;p>At this point, we&amp;rsquo;ve optimized inter-process communication to its extremes. If we are to seek further improvements, we need to break through the existing constraints in Linux inter-process communication fundamentally.&lt;/p>
&lt;p>We&amp;rsquo;ve already made some preliminary strides in this area. We will continue to share updates on this topic in future articles, so stay tuned.&lt;/p>
&lt;h2 id="reassessing-the-tcp-protocol">Reassessing the TCP Protocol&lt;/h2>
&lt;p>In the context of internal data center communication, the TCP protocol displays some limitations:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Given the superior internal network quality and an incredibly low packet loss rate, many designs within TCP appear redundant.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>In situations of large-scale point-to-point communication, TCP long connections may inadvertently degrade into short connections.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>While the application layer uses &amp;ldquo;messages&amp;rdquo; as a unit, TCP data streams don&amp;rsquo;t offer clear message boundaries, which could complicate synchronization and message handling.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>This has led us to question whether we need to develop a proprietary data center protocol, better suited to handle RPC communication.&lt;/p>
&lt;h2 id="continuing-to-refine-existing-components">Continuing to Refine Existing Components&lt;/h2>
&lt;p>When it comes to existing components, we plan to continue our efforts to enhance their performance and applicability:&lt;/p>
&lt;p>&lt;strong>Frugal, the Thrift JIT Encoder/Decoder:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Introducing support for the ARM architecture.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Optimizing the backend with Static Single Assignment (SSA).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Accelerating performance with Single Instruction, Multiple Data (SIMD) operations.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Netpoll Network Library:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Refactoring interfaces to ensure seamless integration with existing libraries in the Go ecosystem.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Implementing support for Shared Memory Communications over RDMA (SMC-R).&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Pod Affinity:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Expanding from same-machine to same-rack granularity, effectively reducing network latency and improving performance.&lt;/li>
&lt;/ul>
&lt;p>In this post, we explored optimizing microservices performance using Kitex, the RPC framework developed by ByteDance. We discussed various techniques, from encoding and decoding enhancements, JIT compilation, network library optimization, and communication layer upgrades, to automated GC optimization, concurrent processing strategies, and microservices online tuning practices.&lt;/p>
&lt;p>Kitex has demonstrated its ability to outperform other frameworks in testing comparisons, showcasing its strength in handling complex microservice architectures.&lt;/p>
&lt;p>We also briefly looked towards future optimizations, including kernel-level improvements, restructuring the TCP protocols, and further refinement of existing components. With continuous learning and improvements, we are driven to unlock the vast potential in microservice performance optimization, taking us one step closer to the realm of real-time computing.&lt;/p>
&lt;p>For any questions or discussions, you&amp;rsquo;re welcome to join our community on &lt;a href="https://github.com/cloudwego">GitHub&lt;/a> or &lt;a href="https://discord.gg/jceZSE7DsW">Discord&lt;/a>.&lt;/p></description></item><item><title>Blog: Harnessing the Power of Rust for Cloud Development with Volo</title><link>https://www.cloudwego.io/blog/2024/01/18/harnessing-the-power-of-rust-for-cloud-development-with-volo/</link><pubDate>Thu, 18 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/blog/2024/01/18/harnessing-the-power-of-rust-for-cloud-development-with-volo/</guid><description>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Harnessing_the_Power_of_Rust_for_Cloud_Development_with_Volo/1.jpeg" alt="Image">&lt;/p>
&lt;h2 id="i-introduction">I. Introduction&lt;/h2>
&lt;p>Every tool in the &lt;a href="https://www.cloudwego.io">CloudWeGo&lt;/a> open-source ecosystem has been developed with the aim of simplifying and revolutionizing how developers navigate the cloud environment. An essential part of this ecosystem is &lt;a href="https://www.cloudwego.io/docs/volo/">Volo&lt;/a>, a Rust RPC framework designed to provide a seamless and efficient communication infrastructure.&lt;/p>
&lt;p>This guide aims to provide in-depth insights into leveraging Volo in your projects. Built with &lt;a href="https://www.rust-lang.org">Rust&lt;/a>, Volo brings unique features and advantages into the mix.&lt;/p>
&lt;h2 id="ii-the-power-of-rust-based-volo-in-the-real-world">II. The Power of Rust-Based Volo in the Real World&lt;/h2>
&lt;p>As a part of the CloudWeGo family, Volo can make a significant impact in real-world applications. Its high-speed processing capabilities, when combined with the safety and concurrency advantages of Rust, can provide an efficient backbone to high-performance web services and applications.&lt;/p>
&lt;p>The beauty of Rust, which Volo encapsulates, is its ability to push beyond the performance boundaries typically associated with languages such as Go. While Go is highly efficient, it does reach a performance ceiling that may not lend itself to deep optimization. However, once a finely optimized Go service is rewritten in Rust, the benefits spring into view.&lt;/p>
&lt;p>Here, CPU gains generally rise above 30%, some even reaching over 50%. In some cases, a fourfold increase in CPU gains is observed. Memory gains are even more pronounced, regularly topping 50% and in some cases reaching as high as 90%.&lt;/p>
&lt;p>Beyond performance, Rust addresses the unpredictable jitter issues brought about by &lt;a href="https://tip.golang.org/doc/gc-guide">Go&amp;rsquo;s garbage collection (GC)&lt;/a>. In doing so, it helps businesses significantly reduce timeout/error rates, decrease P99 latency, and improve the service level agreements (SLA) of their offerings.&lt;/p>
&lt;p>Consider the infrastructure of an online marketplace&amp;rsquo;s back-end. Volo can facilitate seamless interactions between the users, the product database, and third-party services, making them more efficient and reliable.&lt;/p>
&lt;p>Another use case could be in the gaming industry, where Volo can help manage player data, game state, and real-time multiplayer interactions with low-latency and high reliability.&lt;/p>
&lt;p>Rust and Go are not adversaries but rather allies that complement each other, leveraging their respective strengths to compensate for any weaknesses. For applications where ultimate performance, low latency, memory bottlenecks, and stability are of paramount importance, even if it comes at the cost of some iteration speed loss, Rust is the go-to choice.&lt;/p>
&lt;p>These applications can fully benefit from Rust&amp;rsquo;s, and by extension Volo&amp;rsquo;s, unrivaled performance optimization and security. However, when performance sensitivity takes a backseat to high I/O operations, and when rapid development and iteration receives priority over stability, Go becomes the preferred choice.&lt;/p>
&lt;p>Rust&amp;rsquo;s vast applicability doesn&amp;rsquo;t stop at server-side business and architectural domains. Its exploratory and implementation journey extends to areas such as internal safety, kernel development, AI, frontend, and client-side development. As such, Volo, with its Rust foundation, carries this adaptability and flexibility, ready to conquer diverse domains and real-world challenges.&lt;/p>
&lt;h2 id="iii-getting-started-with-cloudwego">III. Getting Started With CloudWeGo&lt;/h2>
&lt;p>CloudWeGo provides a robust set of tools to work with, one of which is Volo. Here&amp;rsquo;s how you can kickstart your journey with Volo within the CloudWeGo ecosystem.&lt;/p>
&lt;h3 id="volo">Volo&lt;/h3>
&lt;h4 id="prerequisites">Prerequisites&lt;/h4>
&lt;p>If you don’t have the Rust development environment set up, please follow &lt;a href="https://www.rust-lang.org/tools/install">Install Rust&lt;/a> to download Rustup and install Rust. Volo supports Linux, macOS, and Windows systems by default.&lt;/p>
&lt;h4 id="install-the-cli-tool">Install the CLI tool&lt;/h4>
&lt;p>Volo provides CLI tools of the same name for initializing projects, managing IDLs, and more. To install Volo tool, run the following command: &lt;code>cargo install volo-cli&lt;/code>.&lt;/p>
&lt;p>Then run: &lt;code>volo help&lt;/code>&lt;/p>
&lt;p>You should see something similar to the following:&lt;/p>
&lt;pre tabindex="0">&lt;code>USAGE:
volo [OPTIONS] &amp;lt;SUBCOMMAND
OPTIONS:
-h, --help Print help information
-n, --entry-name &amp;lt;ENTRY_NAME The entry name, defaults to &amp;#39;default&amp;#39;. [default: default]
-v, --verbose Turn on the verbose mode.
-V, --version Print version information
SUBCOMMANDS: help Print this message or the help of the given subcommand(s)
idl manage your idl
&lt;/code>&lt;/pre>&lt;h2 id="iv-creating-a-sample-project-with-cloudwego">IV. Creating A Sample Project With CloudWeGo&lt;/h2>
&lt;p>When starting a new project with Volo, the following steps can guide you through the development of basic components.&lt;/p>
&lt;h3 id="thrift-project">Thrift project&lt;/h3>
&lt;p>&lt;strong>1. Write IDL&lt;/strong>&lt;/p>
&lt;p>To create a Thrift project, we need to write a Thrift IDL first. In your working directory, execute the following command:&lt;/p>
&lt;pre tabindex="0">&lt;code>mkdir volo-example &amp;amp;&amp;amp; cd volo-example
mkdir idl &amp;amp;&amp;amp; vim idl/volo_example.thrift
&lt;/code>&lt;/pre>&lt;p>Then, enter the following content:&lt;/p>
&lt;pre tabindex="0">&lt;code>namespace rs volo.example
struct Item {
1: required i64 id,
2: required string title,
3: required string content,
10: optional map&amp;lt;string, string&amp;gt; extra,
}
struct GetItemRequest {
1: required i64 id,
}
struct GetItemResponse {
1: required Item item,
}
service ItemService {
GetItemResponse GetItem (1: GetItemRequest req),
}
Init the server project
volo init volo-example idl/volo_example.thrift
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Note:&lt;/strong> Here we use the &lt;code>init&lt;/code> command, followed by the name of our project, which means we need to generate template code. At the end, you need to specify an IDL used by the server.&lt;/p>
&lt;p>At this point, our entire directory structure looks like this:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-." data-lang=".">├── Cargo.toml
├── idl
│ └── volo_example.thrift
├── rust-toolchain.toml
├── src
│ ├── bin
│ │ └── server.rs
│ └── lib.rs
└── volo-gen
├── Cargo.toml
├── build.rs
├── src
│ └── lib.rs
└── volo.yml
&lt;/code>&lt;/pre>&lt;p>&lt;strong>2. Add logic code&lt;/strong>&lt;/p>
&lt;p>Open &lt;code>src/lib.rs&lt;/code> and add the method implementation to the impl block:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-pub" data-lang="pub">
impl volo_gen::volo::example::ItemService for S {
// This is the part of the code we need to add
async fn get_item(
&amp;amp;self,
_req: volo_gen::volo::example::GetItemRequest,
) -&amp;gt; core::result::Result&amp;lt;volo_gen::volo::example::GetItemResponse, volo_thrift::AnyhowError&amp;gt;
{
Ok(Default::default())
}
}
&lt;/code>&lt;/pre>&lt;p>&lt;strong>3. Execute&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>cargo update &amp;amp;&amp;amp; cargo build
&lt;/code>&lt;/pre>&lt;p>At this point, you will find &lt;code>volo_gen.rs&lt;/code> file under &lt;code>OUT_DIR Directory&lt;/code>. Then execute the following command to get our server running:&lt;/p>
&lt;pre tabindex="0">&lt;code>cargo run --bin server
&lt;/code>&lt;/pre>&lt;p>We now have our server running!&lt;/p>
&lt;h3 id="grpc-project">gRPC project&lt;/h3>
&lt;p>&lt;strong>1. Write IDL&lt;/strong>&lt;/p>
&lt;p>To create a gRPC project, we need to write a protobuf IDL first. In your working directory, execute the following command:&lt;/p>
&lt;pre tabindex="0">&lt;code>mkdir volo-example &amp;amp;&amp;amp; cd volo-example
mkdir idl &amp;amp;&amp;amp; vim idl/volo_example.proto
&lt;/code>&lt;/pre>&lt;p>Then, enter the following content:&lt;/p>
&lt;pre tabindex="0">&lt;code>syntax = &amp;#34;proto3&amp;#34;;
package volo.example;
message Item {
int64 id = 1;
string title = 2;
string content = 3;
map&amp;lt;string, string&amp;gt; extra = 10;
}
message GetItemRequest {
int64 id = 1;
}
message GetItemResponse {
Item item = 1;
}
service ItemService {
rpc GetItem(GetItemRequest) returns (GetItemResponse);
}
&lt;/code>&lt;/pre>&lt;p>&lt;strong>2. Init the server project&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>volo init --includes=idl volo-example idl/volo_example.proto
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Note:&lt;/strong> Here we use the &lt;code>init&lt;/code> command, followed by the name of our project, which means we need to generate template code. At the end, you need to specify an IDL used by the server.&lt;/p>
&lt;p>At this point, our entire directory structure looks like this:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-." data-lang=".">├── Cargo.toml
├── idl
│ └── volo_example.proto
├── rust-toolchain.toml
├── src
│ ├── bin
│ │ └── server.rs
│ └── lib.rs
└── volo-gen
├── Cargo.toml
├── build.rs
├── src
│ └── lib.rs
└── volo.yml
&lt;/code>&lt;/pre>&lt;p>&lt;strong>3. Add logic code&lt;/strong>&lt;/p>
&lt;p>Open &lt;code>src/lib.rs&lt;/code> and add the method implementation to the impl block:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-pub" data-lang="pub">
impl volo_gen::volo::example::ItemService for S {
// This is the part of the code we need to add
async fn get_item(
&amp;amp;self,
_req: volo_grpc::Request&amp;lt;volo_gen::volo::example::GetItemRequest&amp;gt;,
) -&amp;gt; core::result::Result&amp;lt;volo_grpc::Response&amp;lt;volo_gen::volo::example::GetItemResponse&amp;gt;, volo_grpc::Status&amp;gt;
{
Ok(volo_grpc::Response::new(Default::default()))
}
}
&lt;/code>&lt;/pre>&lt;p>&lt;strong>4. Execute&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>cargo update &amp;amp;&amp;amp; cargo build
&lt;/code>&lt;/pre>&lt;p>At this point, you will find &lt;code>volo_gen.rs&lt;/code> file under &lt;code>OUT_DIR Directory&lt;/code>. Then execute the following command to get our server running:&lt;/p>
&lt;pre tabindex="0">&lt;code>cargo run --bin server
&lt;/code>&lt;/pre>&lt;p>If you followed the above steps, you&amp;rsquo;ll now have your server running!&lt;/p>
&lt;h2 id="v-troubleshooting-tips--faq">V. Troubleshooting Tips &amp;amp; FAQ&lt;/h2>
&lt;p>Like any technology, working with Volo might come up with its own set of challenges. Here are some tips to handle common issues:&lt;/p>
&lt;p>&lt;strong>- Compilation Errors:&lt;/strong> If you encounter any compilation errors, it&amp;rsquo;s recommended to double-check your Rust environment and Volo setup. Ensure that you have the latest stable version of Rust and that Volo is correctly installed and updated to the latest version.&lt;/p>
&lt;p>&lt;strong>- Runtime Issues:&lt;/strong> If your Volo application runs into issues during runtime, investigate the error messages and logs. Volo errors are designed to be descriptive and should guide you towards the problem source.&lt;/p>
&lt;p>&lt;strong>- Why is the code generated by &lt;code>volo-cli&lt;/code> separately split into the volo-gen crate?&lt;/strong>&lt;/p>
&lt;p>This separation is because Rust&amp;rsquo;s compilation operates on a crate-by-crate basis. Creating the generated code as a separate crate allows for better utilization of the compile cache (idl generally doesn&amp;rsquo;t change frequently).&lt;/p>
&lt;p>&lt;strong>- How compatible is it with Kitex?&lt;/strong>&lt;/p>
&lt;p>Volo is fully compatible with &lt;a href="https://www.cloudwego.io/blog/2024/01/10/mastering-golang-microservices-a-practical-guide-embrace-high-performance-with-kitex-and-hertz/">Kitex&lt;/a>, including functionalities like metadata transmission.&lt;/p>
&lt;h2 id="vi-conclusion">VI. Conclusion&lt;/h2>
&lt;p>This guide provided a comprehensive look into Volo, a powerful Rust-based component of the CloudWeGo ecosystem. With an understanding of how to set up and use Volo in your projects, you&amp;rsquo;re now equipped to harness the speed and efficiency that Volo brings to your cloud development tasks.&lt;/p>
&lt;p>As you continue to explore &lt;a href="https://www.cloudwego.io">CloudWeGo&lt;/a>, keep integrating its powerful features into your projects, and see the transformative impact it can have on your software development process.&lt;/p>
&lt;p>Stay curious, keep learning, and don&amp;rsquo;t hesitate to dive deeper into the boundless potential of CloudWeGo. Happy coding!&lt;/p></description></item><item><title>Blog: Mastering Golang Microservices - A Practical Guide: Embrace High-Performance with Kitex and Hertz</title><link>https://www.cloudwego.io/blog/2024/01/10/mastering-golang-microservices-a-practical-guide-embrace-high-performance-with-kitex-and-hertz/</link><pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/blog/2024/01/10/mastering-golang-microservices-a-practical-guide-embrace-high-performance-with-kitex-and-hertz/</guid><description>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Mastering_Golang_Microservices_A_Practical_Guide_Embrace_High_Performance_with_Kitex_and_Hertz/1.jpeg" alt="Image">&lt;/p>
&lt;h2 id="i-introduction">I. Introduction&lt;/h2>
&lt;p>The world of software development is fast-paced, and having reliable and efficient tools makes a significant difference.
This is where &lt;a href="https://github.com/cloudwego">CloudWeGo&lt;/a> with two of its major sub-projects - &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> and &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>, comes into play. A solution with the potential to transform the way developers navigate the cloud environment, thanks to its robust, open-source technology.&lt;/p>
&lt;p>Two of its standout components, Kitex and Hertz, are at the center of our focus in this guide. Kitex is an efficient and powerful RPC framework used for communication between microservices, while Hertz aids in the quick and efficient setup of web services and BFF services. Both are designed to simplify and enhance your development efforts.&lt;/p>
&lt;p>Our mission in this guide is simple: to facilitate your understanding of CloudWeGo, its powerful features, and how to harness them in your projects with a clear step-by-step handbook.
Whether you are a seasoned developer familiar with open-source technology or a newcomer exploring cloud development, this guide is designed to cater to your needs.&lt;/p>
&lt;p>Once done reading, you will be comfortable setting up CloudWeGo, initiating and developing a project, implementing testing, debugging, deploying your applications, and more.
We&amp;rsquo;ll also share some of the best practices when using CloudWeGo to ensure that you are maximizing the potential of the CloudWeGo open-source ecosystem. Let&amp;rsquo;s dive in!&lt;/p>
&lt;h2 id="ii-getting-started-with-cloudwego">II. Getting Started With CloudWeGo&lt;/h2>
&lt;p>As key components of CloudWeGo, Kitex &amp;amp; Hertz, are crucial to getting started. Ensuring you have a suitably configured environment with Golang is a pre-requisite. If you are working on a Windows platform, make sure the version of Kitex is v0.5.2 or higher. Hertz, on the other hand, is compatible across Linux, macOS, and Windows systems.&lt;/p>
&lt;p>Installing the CLI tool requires confirmation that the &lt;code>GOPATH&lt;/code> environment variable is correctly defined and accessible. This is followed by installing Kitex, Thriftgo, and Hertz. The correct setup can be verified by running their respective versions. If you encounter any problems, your troubleshooting should involve a check on the setup of the Golang development environment.&lt;/p>
&lt;h3 id="kitex--hertz">Kitex &amp;amp; Hertz&lt;/h3>
&lt;h4 id="prerequisites">Prerequisites&lt;/h4>
&lt;p>Before diving into CloudWeGo development with Kitex &amp;amp; Hertz, make sure you have set up the Golang development environment. Please follow the Install Go guide if you haven&amp;rsquo;t already.&lt;/p>
&lt;p>We highly recommend using the latest version of Golang, ensuring compatibility with three most recent minor release versions (currently &amp;gt;= v1.16).&lt;/p>
&lt;p>Additionally, make sure that &lt;code>GO111MODULE&lt;/code> is set to &lt;code>ON&lt;/code>.&lt;/p>
&lt;h3 id="install-the-cli-tool">Install the CLI tool&lt;/h3>
&lt;p>Let&amp;rsquo;s start by installing the CLI tools we will be working with.
Ensure the &lt;code>GOPATH&lt;/code> environment variable is properly defined (e.g., &lt;code>export GOPATH=~/go&lt;/code>), then add &lt;code>$GOPATH/bin&lt;/code> to the &lt;code>PATH&lt;/code> environment variable (e.g., &lt;code>export PATH=$GOPATH/bin:$PATH&lt;/code>). Make sure that &lt;code>GOPATH&lt;/code> is accessible.&lt;/p>
&lt;p>Next, install Kitex (&lt;code>go install github.com/cloudwego/kitex/tool/cmd/kitex@latest&lt;/code>), Thriftgo (for Thrift protocol - &lt;code>go install github.com/cloudwego/thriftgo@latest&lt;/code>), and Hertz (&lt;code>go install github.com/cloudwego/hertz/cmd/hz@latest&lt;/code>).&lt;/p>
&lt;p>Now, if you run &lt;code>kitex --version&lt;/code>, &lt;code>thriftgo --version&lt;/code>, and &lt;code>hz --version&lt;/code>, you should see output indicating the versions of each CLI tool:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kitex --version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vx.x.x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ thriftgo --version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>thriftgo x.x.x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ hz --version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vx.x.x
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Note:&lt;/strong> If you encounter any issues during the installation, it&amp;rsquo;s likely due to gaps in the setup of the Golang development environment. Usually, you can quickly find a solution by searching for the error message online.&lt;/p>
&lt;h2 id="iii-creating-a-sample-project">III. Creating A Sample Project&lt;/h2>
&lt;h3 id="kitex">Kitex&lt;/h3>
&lt;h4 id="get-the-example">Get the example&lt;/h4>
&lt;ol>
&lt;li>You can simply click &lt;a href="https://github.com/cloudwego/kitex-examples/archive/refs/heads/main.zip">here&lt;/a> to download the example.&lt;/li>
&lt;li>Or you can clone the sample repository &lt;code>git clone https://github.com/cloudwego/kitex-examples.git&lt;/code>.&lt;/li>
&lt;/ol>
&lt;h4 id="run-the-example">Run the example&lt;/h4>
&lt;h5 id="run-with-go">Run with go&lt;/h5>
&lt;ol>
&lt;li>Change to the &lt;code>hello&lt;/code> directory. Hello is a simple example of Kitex using the Thrift protocol.
&lt;code>cd kitex-examples/hello&lt;/code>&lt;/li>
&lt;li>Run server
&lt;code>go run .&lt;/code>&lt;/li>
&lt;li>Run client
open another terminal and &lt;code>go run ./client.&lt;/code>&lt;/li>
&lt;/ol>
&lt;h5 id="run-with-docker">Run with Docker&lt;/h5>
&lt;ol>
&lt;li>Go to the examples directory
&lt;code>cd kitex-examples&lt;/code>&lt;/li>
&lt;li>Build the example project
&lt;code>docker build -t kitex-examples&lt;/code>.&lt;/li>
&lt;li>Run the server
&lt;code>docker run --network host kitex-examples ./hello-server&lt;/code>&lt;/li>
&lt;li>Run the client
Open another terminal and run &lt;code>docker run --network host kitex-examples ./hello-client&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>Congratulations! You now have successfully used Kitex to complete an RPC.&lt;/p>
&lt;h3 id="hertz">Hertz&lt;/h3>
&lt;h5 id="quick-start">Quick Start&lt;/h5>
&lt;p>To create a sample project with Hertz, start by creating the &lt;code>hertz_demo&lt;/code> folder in the current directory and navigate to that directory. Then, create the &lt;code>main.go&lt;/code> file and add the following code:
package main&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">import&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4e9a06">&amp;#34;context&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4e9a06">&amp;#34;github.com/cloudwego/hertz/pkg/app&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4e9a06">&amp;#34;github.com/cloudwego/hertz/pkg/app/server&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4e9a06">&amp;#34;github.com/cloudwego/hertz/pkg/protocol/consts&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">main&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">h&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">server&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Default&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">h&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">GET&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;/ping&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">c&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">app&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">RequestContext&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">c&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">JSON&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">consts&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">StatusOK&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">app&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">H&lt;/span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;message&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;pong&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">})&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">})&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">h&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Spin&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Next, generate the &lt;code>go.mod&lt;/code> file (&lt;code>go mod init hertz_demo&lt;/code>), then tidy &amp;amp; get dependencies (&lt;code>go mod tidy&lt;/code>).&lt;/p>
&lt;p>To run the sample code, simply type &lt;code>go run hertz_demo&lt;/code>. If the server is launched successfully, you will see the following message:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2022/05/17 21:47:09.626332 engine.go:567: &lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>Debug&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span> HERTZ: &lt;span style="color:#000">Method&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>GET &lt;span style="color:#000">absolutePath&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>/ping -- &lt;span style="color:#000">handlerName&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>main.main.func1 &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#000">num&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span> handlers&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/05/17 21:47:09.629874 transport.go:84: &lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>Info&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span> HERTZ: HTTP server listening on &lt;span style="color:#000">address&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=[&lt;/span>::&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>:8888
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can test the interface by typing &lt;code>curl http://127.0.0.1:8888/ping&lt;/code>. If everything is working correctly, you should see the following output:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;message&amp;#34;&lt;/span>:&lt;span style="color:#4e9a06">&amp;#34;pong&amp;#34;&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="using-cli-tool-hz">Using CLI tool hz&lt;/h5>
&lt;p>You can also use the Hertz CLI tool to generate a sample project outside of the &lt;code>GOPATH&lt;/code>. Procedures include creating an IDL file named &lt;code>hello.thrift&lt;/code>, generating the sample code, obtaining the dependencies, and subsequently running the sample code.
Assuming you are working on a folder outside of &lt;code>GOPATH&lt;/code>, create an IDL file called &lt;code>hello.thrift&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-thrift" data-lang="thrift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">namespace&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">go&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">hello.world&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">service&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">HelloService&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">string&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Hello&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">string&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">name&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Generate or complete the Sample Code using &lt;code>hz new -idl hello.thrift -module hertz_demo&lt;/code>.&lt;/p>
&lt;p>&lt;strong>Note:&lt;/strong> since you&amp;rsquo;re currently not in &lt;code>GOPATH&lt;/code>, you&amp;rsquo;ll need to add &lt;code>-module&lt;/code> or &lt;code>-mod&lt;/code> flag to specify a custom module name. After execution, a scaffolding of the Hertz project is created in the current directory, with a ping interface for testing.&lt;/p>
&lt;p>Get dependencies (&lt;code>go mod tidy&lt;/code>), then run the sample code (&lt;code>go build -o hertz_demo &amp;amp;&amp;amp; ./hertz_demo&lt;/code>).&lt;/p>
&lt;p>If the server is launched successfully, you will see the same message as before, and you can test the interface using the same curl command. Congratulations, you&amp;rsquo;ve successfully launched the Hertz Server!&lt;/p>
&lt;h2 id="iv-testing-and-debugging-your-project">IV. Testing and Debugging Your Project&lt;/h2>
&lt;p>Testing and debugging your project are essential components whether you are working with Kitex or Hertz.
While dealing with Kitex errors, the &lt;code>IsKitexError&lt;/code> method in the kerrors package can be used.&lt;/p>
&lt;p>The Kitex framework automatically recovers all panics except those occurring within the goroutine created by the business code using the &lt;code>go&lt;/code> keyword.&lt;/p>
&lt;h3 id="kitex-1">Kitex&lt;/h3>
&lt;h4 id="exception-instruction">Exception Instruction&lt;/h4>
&lt;p>Check for Kitex errors using &lt;code>kerrors.IsKitexError(kerrors.ErrInternalException)&lt;/code>. You can check for a specified error type using &lt;code>errors.Is(err, kerrors.ErrNoResolver)&lt;/code>. Also, note that you can use &lt;code>IsTimeoutError&lt;/code> in kerrors to check whether it&amp;rsquo;s a timeout error.&lt;/p>
&lt;p>To get detailed error messages, all detailed errors are defined by &lt;code>DetailedError&lt;/code> in kerrors. You can use &lt;code>errors.As&lt;/code> to fetch specified &lt;code>DetailedError&lt;/code>.&lt;/p>
&lt;p>For example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">import&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;errors&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">import&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;github.com/cloudwego/kitex/client&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">import&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;github.com/cloudwego/kitex/pkg/kerrors&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">_&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">echo&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">NewClient&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;echo&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">client&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">WithResolver&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">nil&lt;/span>&lt;span style="color:#000;font-weight:bold">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">var&lt;/span> &lt;span style="color:#000">de&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">kerrors&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">DetailedError&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">ok&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">errors&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">As&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">err&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">de&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>DetailedError&lt;/code> provides the following methods to fetch a detailed message:&lt;/p>
&lt;ul>
&lt;li>&lt;code>ErrorType() error&lt;/code>: to get the basic error type&lt;/li>
&lt;li>&lt;code>Stack() string&lt;/code>: to get the stack (currently only works for &lt;code>ErrPanic&lt;/code>)&lt;/li>
&lt;/ul>
&lt;h3 id="handling-panic">Handling panic&lt;/h3>
&lt;p>Panic that occurs in the goroutine created by the business code using the go keyword must be recovered by the business code. To ensure the stability of the service, the Kitex framework will automatically recover all other panics.&lt;/p>
&lt;p>While checking for recovered panic in your middlewares, you can use &lt;code>ri.Stats().Panicked()&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// After calling next(...) in your middleware:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">ri&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">rpcinfo&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">GetRPCInfo&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">stats&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">ri&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Stats&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span> &lt;span style="color:#000">stats&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">panicked&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">stats&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Panicked&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span> &lt;span style="color:#000">panicked&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// err is the object kitex get by calling recover()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="faq--answers">FAQ &amp;amp; Answers&lt;/h4>
&lt;p>&lt;strong>Q1: &lt;code>Not enough arguments&lt;/code> problem when installing the code generation tool&lt;/strong>&lt;/p>
&lt;p>Please try:
&lt;code>go mod：GO111MODULE=on go get github.com/cloudwego/kitex/tool/cmd/kitex@latest&lt;/code>&lt;/p>
&lt;p>&lt;strong>Q2: Why does &lt;code>set&lt;/code> in IDL become &lt;code>slice&lt;/code> in generated codes?&lt;/strong>&lt;/p>
&lt;p>Due to JSON serialization, the official Apache Thrift changed the generation type of &lt;code>set&lt;/code> from &lt;code>map&lt;/code> to &lt;code>slice&lt;/code> starting from v0.11.0. To ensure compatibility, Kitex follows this rule.&lt;/p>
&lt;p>&lt;strong>Q3: Why is there an underscore after some field names?&lt;/strong>&lt;/p>
&lt;p>The official implementation of Thrift forbids identifiers ending in &amp;ldquo;Result&amp;rdquo; and &amp;ldquo;Args&amp;rdquo; to avoid naming conflicts. When the type name, service name, and method name in the Thrift file start with &amp;ldquo;New&amp;rdquo; or end with &amp;ldquo;Result&amp;rdquo; or &amp;ldquo;Args&amp;rdquo;, an underscore is automatically added at the end of the name.&lt;/p>
&lt;p>&lt;strong>Q4: Does the code generated by a new interface overwrite &lt;code>handler.go&lt;/code>?&lt;/strong>&lt;/p>
&lt;p>Generated code under &lt;code>kitex_gen/&lt;/code> will be overwritten. However, &lt;code>handler.go&lt;/code> of the server will not be overwritten; new methods will be added correspondingly.&lt;/p>
&lt;p>&lt;strong>Q5: &amp;ldquo;Not enough arguments in call to &lt;code>iprot.ReadStructBegin&lt;/code> when compiling Thrift interface&lt;/strong>&lt;/p>
&lt;p>Kitex is based on Apache Thrift v0.13 and cannot be directly upgraded since there is a breaking change in Apache Thrift v0.14. Such issues usually arise if a new version of Thrift is pulled during upgrades.&lt;/p>
&lt;p>We recommend against using &lt;code>-u&lt;/code> parameters during upgrades. You can run the following command to fix the version: &lt;code>go mod edit -replace github.com/apache/thrift=github.com/apache/thrift@v0.13.0&lt;/code>&lt;/p>
&lt;h3 id="hertz-1">Hertz&lt;/h3>
&lt;h4 id="error-type--error-chain">Error Type &amp;amp; Error Chain&lt;/h4>
&lt;p>To handle errors more effectively, Hertz has predefined several error types:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ErrorTypeBind:&lt;/strong> Error in binding process&lt;/li>
&lt;li>&lt;strong>ErrorTypeRender:&lt;/strong> Error in rendering process&lt;/li>
&lt;li>&lt;strong>ErrorTypePrivate:&lt;/strong> Hertz private errors that business doesn&amp;rsquo;t need to be aware of&lt;/li>
&lt;li>&lt;strong>ErrorTypePublic:&lt;/strong> Hertz public errors that require external perception as opposed to Private&lt;/li>
&lt;li>&lt;strong>ErrorTypeAny:&lt;/strong> Other Error&lt;/li>
&lt;/ul>
&lt;p>Users should define corresponding errors according to these error types.
In addition to error definition conventions, Hertz also provides &lt;code>ErrorChain&lt;/code> capability to make it easier for businesses to bind all errors encountered during request processing to an error chain.&lt;/p>
&lt;p>The corresponding API for this is &lt;code>RequestContext.Error(err)&lt;/code>. Calling this API will tie the err to its corresponding request context. To get all the errors bound by the request context, use &lt;code>RequestContext.Errors&lt;/code>.&lt;/p>
&lt;h4 id="faq--answers-1">FAQ &amp;amp; Answers&lt;/h4>
&lt;p>&lt;strong>Q1: High Memory Usage&lt;/strong>&lt;/p>
&lt;p>Connections not Closing due to Client Non-standard Usage: If the client initiates a large number of connections without closing them, there can be a significant waste of resources over time, causing high memory usage problems.
To resolve this, configure &lt;code>idleTimeout&lt;/code> reasonably. Hertz Server will close the connection to ensure the server&amp;rsquo;s stability after the timeout. The default configuration is three minutes.&lt;/p>
&lt;p>&lt;strong>Q2: Vast Request/Response&lt;/strong>&lt;/p>
&lt;p>If the request and response are vast, the data will enter memory, causing significant pressure, especially when stream and chunk are not used. To resolve this, for very vast requests cases, use a combination of streaming and go net.&lt;/p>
&lt;p>&lt;strong>Q3: Common Error Code Checking&lt;/strong>&lt;/p>
&lt;p>The following error codes are commonly reported by the framework:&lt;/p>
&lt;ul>
&lt;li>404 (Access to the wrong port or No routes matched)&lt;/li>
&lt;li>417 (The server returns false after executing the custom &lt;code>ContinueHandler&lt;/code>)&lt;/li>
&lt;li>500 (Throwing the panic in middleware or in &lt;code>handlerFunc&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>For more details and solutions on these and other error codes, please refer to the &lt;a href="https://www.cloudwego.io/docs/kitex/getting-started/">Kitex User Guide&lt;/a>.&lt;/p>
&lt;h3 id="context-guide">Context Guide&lt;/h3>
&lt;p>Hertz also provides a standard &lt;code>context.Content&lt;/code> and a request context as input arguments in the function in the &lt;code>HandleFunc&lt;/code> Design. The handler/middleware function signature is:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">HandlerFunc&lt;/span> &lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">c&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">app&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">RequestContext&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="metadata-storage">Metadata Storage&lt;/h4>
&lt;p>Both contexts (c and ctx) have the ability to store values. The choice of which one to use depends on the life cycle of the stored value and the selected context should match. The &lt;code>ctx&lt;/code> is primarily used to store request-level variables, which are recycled after the request ends.&lt;/p>
&lt;p>It is characterized by high query efficiency (the bottom is map), unsafe coroutines and doesn&amp;rsquo;t implement the &lt;code>context.Context&lt;/code> Interface. The &lt;code>c&lt;/code> is passed as the context between middleware/handler. It has all the semantics of context.Content, is safe for coroutines, and all that requires the &lt;code>context.Content&lt;/code> interface as input arguments can just pass &lt;code>c&lt;/code> directly.&lt;/p>
&lt;h2 id="v-observability">V. Observability&lt;/h2>
&lt;p>Monitoring your application is critical. Both Kitex and Hertz provide a Tracer interface that can be implemented for efficient application monitoring. You can make the most of the numerous instrumentation controls and logging capabilities on offer.&lt;/p>
&lt;p>&lt;strong>Note:&lt;/strong> As a framework, it runs with business services. Once the code of services is built, it can be deployed at virtual machines, bare metal machines, or Docker containers as it should be.&lt;/p>
&lt;h3 id="kitex-2">Kitex&lt;/h3>
&lt;h4 id="configuration-and-options">Configuration and options&lt;/h4>
&lt;p>For more details, please check &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/options/server_options/">server option&lt;/a>, &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/options/client_options/">client option&lt;/a>, and &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/options/call_options/">call option&lt;/a>.&lt;/p>
&lt;h5 id="observability">Observability&lt;/h5>
&lt;h6 id="instrumentation-control">Instrumentation Control&lt;/h6>
&lt;p>Kitex supports flexible enabling of basic and fine-grained Instrumentation. This includes a stats level, client tracing stats level control, server tracing stats level control, and more. For more details, please refer to the &lt;a href="https://www.cloudwego.io/docs/kitex/tutorials/observability/">Kitex User Guide&lt;/a>.&lt;/p>
&lt;h5 id="logging">Logging&lt;/h5>
&lt;p>Kitex supports default logger implementation, injection of custom loggers, and redirection of default logger output. For more details, instructions, and examples, please refer to the &lt;a href="https://www.cloudwego.io/docs/kitex/tutorials/observability/">Kitex User Guide&lt;/a>.&lt;/p>
&lt;h5 id="tracing">Tracing&lt;/h5>
&lt;p>Kitex’s OpenTelemetry extension provides support for tracing. For more details, instructions, and examples, please refer to the &lt;a href="https://www.cloudwego.io/docs/kitex/tutorials/observability/">Kitex User Guide&lt;/a>.&lt;/p>
&lt;h5 id="monitoring">Monitoring&lt;/h5>
&lt;p>The framework doesn’t provide any monitoring, but it provides a Tracer interface. This interface can be implemented by yourself and be injected via WithTracer Option. For more details, instructions, and examples, please refer to the &lt;a href="https://www.cloudwego.io/docs/kitex/tutorials/observability/">Kitex User Guide&lt;/a>.&lt;/p>
&lt;h3 id="hertz-2">Hertz&lt;/h3>
&lt;h4 id="configuration-and-options-1">Configuration and options&lt;/h4>
&lt;p>For more details, please check the &lt;a href="https://www.cloudwego.io/docs/hertz/reference/config/">configuration instructions&lt;/a>.&lt;/p>
&lt;h5 id="observability-1">Observability&lt;/h5>
&lt;h6 id="instrumentation">Instrumentation&lt;/h6>
&lt;p>Hertz supports flexible enabling of basic and fine-grained Instrumentation. This includes a stats level, stats level control, and more. For more details, please refer to the &lt;a href="https://www.cloudwego.io/docs/hertz/tutorials/observability/">Hertz User Guide&lt;/a>.&lt;/p>
&lt;h5 id="log">Log&lt;/h5>
&lt;p>Hertz provides a default way to print logs in the standard output. It also provides several global functions, such as &lt;code>hlog.Info&lt;/code>, &lt;code>hlog.Errorf&lt;/code>, &lt;code>hlog.CtxTracef&lt;/code>, and more, which are implemented in &lt;code>pkg/common/hlog&lt;/code>, to call the corresponding methods of the default logger. For more details, instructions, and examples, please refer to the &lt;a href="https://www.cloudwego.io/docs/hertz/tutorials/observability/">Hertz User Guide&lt;/a>.&lt;/p>
&lt;h5 id="tracing-1">Tracing&lt;/h5>
&lt;p>In microservices, link tracing is a very important capability, which plays an important role in quickly locating problems, analyzing business bottlenecks, and restoring the link status of a request.
Hertz provides the capability of link tracking and also supports user-defined link tracking. For more details, instructions, and examples, please refer to the &lt;a href="https://www.cloudwego.io/docs/hertz/tutorials/observability/">Hertz User Guide&lt;/a>.&lt;/p>
&lt;h5 id="monitoring-1">Monitoring&lt;/h5>
&lt;p>The framework doesn’t provide any monitoring, but it provides a Tracer interface. This interface can be implemented by yourself and be injected via WithTracer Option. For more details, instructions, and examples, please refer to the &lt;a href="https://www.cloudwego.io/docs/hertz/tutorials/observability/">Hertz User Guide&lt;/a>.&lt;/p>
&lt;h2 id="vi-best-practices-for-developing-with-cloudwego">VI. Best Practices for Developing with CloudWeGo&lt;/h2>
&lt;p>For a real-world application of Kitex and Hertz, you can explore projects like &lt;a href="https://github.com/cloudwego/biz-demo/tree/main/bookinfo">Bookinfo&lt;/a>, &lt;a href="https://github.com/cloudwego/biz-demo/tree/main/easy_note">Easy Note&lt;/a>, and &lt;a href="https://github.com/cloudwego/biz-demo/tree/main/book-shop">Book Shop&lt;/a>. Each of these scenarios demonstrate different business scenarios and use-cases for various CloudWeGo subprojects.&lt;/p>
&lt;p>Whether you&amp;rsquo;re dealing with merchant or consumer management, notes maintenance, or integrating different middleware, these projects provide valuable insights into the powerful capabilities of Kitex and Hertz in different contexts.&lt;/p>
&lt;p>This guide provides a comprehensive exploration of CloudWeGo&amp;rsquo;s powerful capabilities, particularly its subprojects, Kitex and Hertz. You now have a solid understanding of how to harness these tools effectively in your development projects.&lt;/p>
&lt;p>As you continue delving into CloudWeGo, remember to mix the tool&amp;rsquo;s powerful features with your creativity for impressive results in your software development journey.&lt;/p>
&lt;p>Stay curious, keep exploring, and stay tuned for our upcoming Rust-focused &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> guide, which will introduce you to yet another exciting aspect of CloudWeGo. Happy coding!&lt;/p></description></item><item><title>Blog: The Role of CloudWeGo in Modern Cloud-Native Applications</title><link>https://www.cloudwego.io/blog/2023/11/28/the-role-of-cloudwego-in-modern-cloud-native-applications/</link><pubDate>Tue, 28 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/blog/2023/11/28/the-role-of-cloudwego-in-modern-cloud-native-applications/</guid><description>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/The_Role_of_CloudWeGo_in_Modern_Cloud_Native_Applications/1.png" alt="Image">&lt;/p>
&lt;h1 id="i-introduction">I. Introduction&lt;/h1>
&lt;p>In the current era of infrastructure modernization, the term &amp;ldquo;Cloud-Native Applications&amp;rdquo; has emerged as a significant factor driving the evolution of the IT landscape. These applications inherently embody the concept of flexibility, scalability, and high availability and are built and delivered in a rapid, dynamic manner. They leverage modern application development frameworks and methodologies like microservices, containerization, and DevOps. Amidst the vast array of technologies accelerating the development and deployment of cloud-native applications is CloudWeGo, a notable player offering a distinctive edge to developers and organizations.&lt;/p>
&lt;p>&lt;a href="https://www.cloudwego.io">CloudWeGo&lt;/a>, a brainchild of &lt;a href="https://www.bytedance.com/en/">ByteDance&lt;/a>, has established itself as a set of microservices middleware. It comprises a collection of high-performance, highly extensible, and highly reliable projects focused on microservices communication and governance.
In the face of the rapidly escalating hybrid and cloud-native microservices environment, CloudWeGo has proved to be a powerful fine-tuned tool to cater to the explicit requirements of such architectures. This article will explore the critical role CloudWeGo plays in understanding, architecting, and leveraging modern cloud-native applications.&lt;/p>
&lt;p>In the following sections, we will delve deeper into what exactly CloudWeGo is, its role in facilitating robust cloud-native applications, its specific advantages, and successfully implemented practical use-cases. Our objective is to present a well-rounded view of CloudWeGo&amp;rsquo;s impact and potential in revolutionizing the way cloud-native applications are structured and operated.&lt;/p>
&lt;h1 id="ii-what-is-cloudwego-an-in-depth-look-at-its-foundations-components-and-simplification-of-hybrid-microservices-creation">II. What is CloudWeGo: An In-depth Look at its Foundations, Components, and Simplification of Hybrid Microservices Creation&lt;/h1>
&lt;p>CloudWeGo is no ordinary middleware, but an open-source project empowering developers worldwide. Conceptualized and developed by ByteDance, CloudWeGo is a powerful toolbox for building enterprise-grade cloud-native architectures. It embodies a framework with a triple threat of high performance, high extensibility, and high reliability, making it a force to be reckoned with in the world of microservices.&lt;/p>
&lt;p>At its core, CloudWeGo houses multiple components that serve as the building blocks of its robust architecture:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>&lt;/strong>: This is the heartbeat of CloudWeGo - a high-performance RPC framework that serves as a conduit for communication between different services. Its major contribution lies in supporting seamless and efficient distributed system development.&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>&lt;/strong>: Stepping in as the HTTP framework within CloudWeGo, Hertz plays a pivotal role in supporting different HTTP protocols. Its extensive capabilities provide a solid base for crafting efficient and adaptive cloud-native applications.&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>&lt;/strong>: Serving as the foundation for CloudWeGo&amp;rsquo;s RPC and HTTP frameworks, Netpoll is an integral network library tailored for high-performance I/O scenarios. It&amp;rsquo;s framed explicitly with an eye on Linux optimization, enabling effective and optimized networking operations.&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://github.com/cloudwego/shmipc-go">Shmipc&lt;/a>&lt;/strong>: CloudWeGo&amp;rsquo;s inter-process communication library paves the way for efficient communication between different processes within the same system space. Shmipc eliminates unnecessary network I/O operations, bolstering overall operational efficiency and performance.&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a>&lt;/strong>: A home-brewed Rust-based RPC framework by CloudWeGo. This project exemplifies the organization’s commitment to developing cutting-edge, high-performance applications, offering a fresh perspective for developers accustomed to Golang and looking to dabble in Rust.&lt;/li>
&lt;/ol>
&lt;p>CloudWeGo’s strategic packaging and unification of these core components results in a cohesive, versatile and scalable microservices middleware, simplifying the task of creating complex hybrid microservices. Enterprises today are no strangers to utilizing different technological frameworks, languages, and platforms to cater to diverse functionality requirements. This need for diversity often calls for a hybrid microservices setup, where teams build different microservices using disparate programming languages, each optimized for a specific task.&lt;/p>
&lt;p>With CloudWeGo, developers enjoy the flexibility of constructing and seamlessly integrating such heterogeneous services, all while maintaining high performance and reliability. The platform&amp;rsquo;s interoperability, inclusive of &lt;a href="https://grpc.io">gRPC&lt;/a>, &lt;a href="https://thrift.apache.org">Thrift&lt;/a>, and other custom protocols, ensures a smooth connection between different services, making the building of hybrid microservices a more straightforward task. By seamlessly weaving together diverse microservices, irrespective of their language of construction, CloudWeGo successfully simplifies the otherwise daunting process of creating hybrid microservices architectures.&lt;/p>
&lt;p>Whether you&amp;rsquo;re a seasoned veteran or a beginner developer just starting in the world of microservices, CloudWeGo simplifies the journey, making the complex and challenging world of hybrid microservices a little less daunting and a lot more exciting.&lt;/p>
&lt;h1 id="iii-role-of-cloudwego-in-cloud-native-applications">III. Role of CloudWeGo in Cloud-Native Applications&lt;/h1>
&lt;p>In our fast-paced digital world, cloud-native applications are revolutionizing how businesses function. By leveraging cloud computing capabilities, these applications aim to enhance scalability, flexibility, and resilience. They adhere to a diverse set of requirements and characteristics:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Microservices Architecture&lt;/strong>: Applications are segmented into smaller, loosely coupled services, each fulfilling a specific function, creating a landscape that enables easier scalability, maintenance, and deployment.&lt;/li>
&lt;li>&lt;strong>Containerization&lt;/strong>: Packaging applications into containers like &lt;a href="https://www.docker.com">Docker&lt;/a>, that encapsulate the code, dependencies, and configurations, ensures uniformity across different environments and expedites deployment.&lt;/li>
&lt;li>&lt;strong>Orchestration and Automation&lt;/strong>: Tools such as &lt;a href="https://kubernetes.io">Kubernetes&lt;/a> excellently manage containerized applications by automating deployment, scaling, and service management, ensuring high availability and optimal resource utilization.&lt;/li>
&lt;li>&lt;strong>DevOps Practices&lt;/strong>: The deployment of Continuous Integration/Continuous Deployment (CI/CD) pipelines accelerates the software delivery process. This approach promotes regular and reliable code updates, facilitated by automated testing, version control, and deployment.&lt;/li>
&lt;li>&lt;strong>Scalability and Elasticity&lt;/strong>: Applications must efficiently scale both vertically (expanding resources within a single node) and horizontally (adding more nodes) to cater to changing workloads. Resource scalability and autoscaling features facilitated through cloud-based resources, handle this necessity.&lt;/li>
&lt;li>&lt;strong>Resilience and Fault Tolerance&lt;/strong>: Robust cloud-native applications are engineered to gracefully handle failures. Incorporating redundancy, failover mechanisms, and self-healing facilities ensures functionality despite component failures.&lt;/li>
&lt;li>&lt;strong>Security and Compliance&lt;/strong>: Implementing robust security measures is pivotal. Inclusion of features like encryption, identity management, access control, and compliance with regulations such as &lt;a href="https://gdpr-info.eu">GDPR&lt;/a>, built into the application architecture, is a requisite.&lt;/li>
&lt;li>&lt;strong>Observability&lt;/strong>: Comprehensive tracking of performance and logging capabilities are key to detect issues, locate system bottlenecks, and garner insights into system behavior. Tools like &lt;a href="https://prometheus.io">Prometheus&lt;/a>, &lt;a href="https://grafana.com">Grafana&lt;/a>, and &lt;a href="https://www.jaegertracing.io">Jaeger&lt;/a> often support this functionality.&lt;/li>
&lt;li>&lt;strong>Cost Efficiency&lt;/strong>: Efficient resource usage is crucial to control costs in a cloud environment. To that end, leveraging cloud provider services effectively, employing auto-scaling, monitoring resource consumption, and optimizing performance end-to-end is a must.&lt;/li>
&lt;/ol>
&lt;p>Implementing these principles leads to the creation of agile, scalable, and resilient applications, perfectly suited for the dynamic demands of contemporary business environments in the cloud.&lt;/p>
&lt;p>Despite numerous benefits, constructing cloud-native applications poses several challenges:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Complexity in Architecture&lt;/strong>: Adopting a microservices architecture introduces complexity in managing multiple services, dependencies, and interactions.&lt;/li>
&lt;li>&lt;strong>Skill Set Requirements&lt;/strong>: Developing cloud-native applications calls for competency in multiple technologies, making it challenging for organizations to acquire and retain talent.&lt;/li>
&lt;li>&lt;strong>Security Concerns&lt;/strong>: The distributed environment elevates the potential attack surface. It&amp;rsquo;s crucial to ensure each service&amp;rsquo;s security, secure communication channels, and manage access control across all components.&lt;/li>
&lt;li>&lt;strong>Resilience and Fault Tolerance&lt;/strong>: Ensuring resilience and fault tolerance requires careful planning for fault detection, recovery, retries, and service availability assurance despite failures.&lt;/li>
&lt;li>&lt;strong>Networking Complexity&lt;/strong>: Communication between services and managing networking configurations in a microservices-based architecture can get intricate, adding service discovery, load balancing, and handling network latency to the list of challenges.&lt;/li>
&lt;li>&lt;strong>Continuous Monitoring and Observability&lt;/strong>: Implementing comprehensive monitoring and logging across microservices can be challenging, though it&amp;rsquo;s crucial for detecting issues and optimizing the system.&lt;/li>
&lt;/ol>
&lt;p>Overcoming these challenges requires the adoption of best practices, leveraging appropriate technologies, investing in skill development, and continually evolving strategies.&lt;/p>
&lt;p>That&amp;rsquo;s where CloudWeGo steps in as a comprehensive microservices solution:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Simplifying Architectural Complexity&lt;/strong>: CloudWeGo integrates rich microservices best practices. It facilitates easy construction of a microservices architecture, handling service mesh integration, reducing costs, and driving optimal performance.&lt;/li>
&lt;li>&lt;strong>Addressing Skill Set Requirements&lt;/strong>: CloudWeGo streamlines the learning curve by providing all-in-one solutions for different scenarios – microservices vs. monoliths, Golang vs. Rust, RPC vs. RESTful, Protobuf vs. Thrift.&lt;/li>
&lt;li>&lt;strong>Ensuring Security&lt;/strong>: CloudWeGo prioritizes security, incorporating several measures. It enables identity management, access controls, and continuous security audits due to its open-source nature and follows industry best practices to ensure application security.&lt;/li>
&lt;li>&lt;strong>Promoting Resilience and Fault Tolerance&lt;/strong>: The Governance module of CloudWeGo boosts resilience and fault tolerance. With features such as timeout control, circuit breaking, rate-limiting, and fallbacks integrated into the Kitex RPC framework, system reliability is assured.&lt;/li>
&lt;li>&lt;strong>Simplifying Networking&lt;/strong>: CloudWeGo supports most popular registry centers for service discovery and registry. It manages intricate networking concerns through both Kitex and Hertz, which have built-in support and detailed guides for integration.&lt;/li>
&lt;li>&lt;strong>Enhancing Observability&lt;/strong>: With in-built Logging, Tracing, and Monitoring capabilities aided by &lt;a href="https://opentelemetry.io">OpenTelemetry&lt;/a> implementation, CloudWeGo significantly improves the observability of cloud-native applications.&lt;/li>
&lt;/ol>
&lt;p>CloudWeGo also incorporates several specific features tailored for cloud-native applications such as high-performance, high extensibility, and high reliability. These offerings, combined with the power of its key components - Kitex, Hertz, Netpoll, Shmipc, and Volo - make CloudWeGo a versatile toolset for efficient and effective cloud-native application development.&lt;/p>
&lt;h1 id="iv-advantages-of-using-cloudwego">IV. Advantages of Using CloudWeGo&lt;/h1>
&lt;h3 id="cloudwego-synonymous-with-reliability">CloudWeGo: Synonymous with Reliability&lt;/h3>
&lt;p>In an environment that demands stability and dependability, CloudWeGo shines as a reliable framework for developers and enterprises. Its focus on meticulous quality assurance, including extensive code reviews and testing, ensures that potential issues are addressed early on before impacting a production environment. CloudWeGo&amp;rsquo;s strong emphasis on stability reflects in the remarkable care the community dedicates toward PR integration, thorough testing, and constant monitoring. The project&amp;rsquo;s frameworks are optimized to effortlessly handle high workloads, guaranteeing stability and reliability, even under considerable pressure. Being open-source, CloudWeGo encourages community members to contribute feedback, driving continual improvement and swift issue resolution while adhering to rigorous quality standards. As a result, CloudWeGo projects are trusted to deliver stable and dependable software solutions continually.&lt;/p>
&lt;h3 id="power-of-performance-the-role-of-netpoll">Power of Performance: The Role of Netpoll&lt;/h3>
&lt;p>CloudWeGo astounds with its high performance, a direct result of incorporating features like asynchronous RPC, streaming RPC, event-driven programming, high-performance non-blocking I/O networking through Netpoll, and support for protocols like HTTP/2. This powerful blend enables CloudWeGo projects to tackle demanding workloads and achieve impressive performance metrics. It marks a testament to CloudWeGo&amp;rsquo;s commitment to speed, responsiveness, and efficiency, ensuring admirable performance at an industrial production level.&lt;/p>
&lt;h3 id="flexibility-through-extensibility--interoperability">Flexibility Through Extensibility &amp;amp; Interoperability&lt;/h3>
&lt;p>A standout feature of CloudWeGo lies in its designed extensibility, allowing users to customize its functionality to suit their individual needs. CloudWeGo employs a modular or layered framework providing a set of interfaces and default implementation options.&lt;/p>
&lt;p>The layered design, evident in Kitex and Hertz, allows developers to infuse their implementations into the framework, customizing it for specific needs. This extensibility enables them to replace or enhance default implementations, adapting CloudWeGo to distinct use cases or seamless integration with other libraries and tools.&lt;/p>
&lt;p>The common open standard protocols like Thrift, HTTP and gRPC, supported by CloudWeGo, are language-independent, making it interoperable with other frameworks. Coupled with Kitex&amp;rsquo;s full support for &lt;a href="https://github.com/alibaba/hessian2-codec">Hessian2&lt;/a> protocol, it promotes interoperability with &lt;a href="https://dubbo.apache.org/en/index.html">Apache Dubbo&lt;/a> and more. This vast interoperability toolset ensures CloudWeGo&amp;rsquo;s strong presence in the cloud-native applications ecosystem, making it the ideal choice for developers on the hunt for a versatile yet powerful framework.&lt;/p>
&lt;p>By combining reliability, high performance, extensibility, and interoperability, CloudWeGo can be an invaluable asset for modern software development, setting a standard for what a comprehensive and robust framework should embody. Regardless of the complexity of the needs or the unique specifications of an application, CloudWeGo has something to offer to every developer. Our active community also ensures that the software stays relevant to the changing tech landscape, making your investment in learning and implementing CloudWeGo worthwhile.&lt;/p>
&lt;h1 id="v-real-world-use-cases-of-cloudwego">V. Real-World Use-Cases of CloudWeGo&lt;/h1>
&lt;p>CloudWeGo is designed for flexibility, managing to cater to a vast range of applications such as microservices-based applications, cloud-native applications, real-time applications, IoT applications, and more. Let&amp;rsquo;s explore some of its successful industry adoptions:&lt;/p>
&lt;h3 id="powering-the-gaming-industry">Powering the Gaming Industry&lt;/h3>
&lt;p>CloudWeGo offers a plethora of benefits for the gaming industry. The platform stands synonymous with increased scalability, optimized performance, and simplified business logic, made possible due to its resource-efficient components like rate limiting, monitoring, and service registration/discovery. Additionally, integration with OpenTelemetry offers valuable monitoring and diagnostics capabilities for developers to optimize game services and ensure an exceptional gaming experience.&lt;/p>
&lt;p>&lt;a href="https://www.tanwan.com/game/">Tanwan Games&lt;/a>, known for popular games such as &lt;a href="https://play.google.com/store/apps/details?id=com.twon.westwar">West War&lt;/a>, faced substantial technical challenges around instantaneous high concurrency during game launches, game updates, extensive data pushes from partners, and interface overloads.&lt;/p>
&lt;p>To overcome these challenges, they turned to CloudWeGo, employing the Hertz framework for HTTP services and the Kitex framework for RPC microservices. Additionally, they leveraged Nacos for service discovery and registration, OpenTelemetry for tracing, Prometheus for monitoring, and Kitex&amp;rsquo;s built-in rate-limiting strategies for traffic shaping. The tangible benefits of embracing CloudWeGo include:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Performance and stability improvement&lt;/strong>: As an example, each Pod of 1c2g succeeded in handling over 400 QPS, with the latency within the network being astonishingly low and rendering a failure rate close to 0%.&lt;/li>
&lt;li>&lt;strong>Enhanced development efficiency, simplified deployment processes, more convenient auto-scaling, increased business elasticity, and reduced costs&lt;/strong>.&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/The_Role_of_CloudWeGo_in_Modern_Cloud_Native_Applications/2.png" alt="Image">&lt;/p>
&lt;h3 id="safeguarding-the-financial-industrys-securities-products">Safeguarding the Financial Industry&amp;rsquo;s Securities&amp;rsquo; Products&lt;/h3>
&lt;p>CloudWeGo, especially through its Kitex framework, has made waves in the financial industry&amp;rsquo;s securities market as well. With the framework&amp;rsquo;s capabilities around service stress testing, efficiency, and secure communication, it became much easier for organizations to maintain stable communication between services within Kubernetes clusters.&lt;/p>
&lt;p>Let&amp;rsquo;s consider &lt;a href="https://www.huaxing.com">Huaxing Securities&lt;/a>, which utilized Kitex for developing its new business product. With carefully integrated tracing libraries for components like &lt;a href="https://gorm.io/index.html">Gorm&lt;/a>, &lt;a href="https://redis.io">Redis&lt;/a>, and &lt;a href="https://kafka.apache.org">Kafka&lt;/a>, they successfully migrated to OpenTelemetry tools like Jaeger for tracing and Prometheus for metrics monitoring. Moreover, they efficiently addressed Kitex&amp;rsquo;s different connection types in Kubernetes environments, resolving issues related to intra-cluster/cross-cluster calls, and achieved multiplexing connections along with seamless rolling upgrades.&lt;/p>
&lt;p>This meticulous implementation resulted in several evident benefits within a mere span of four months, such as rapid construction and launch of the new application, a comprehensive observability system encompassing Log, Trace, and Metrics around the Kitex RPC framework, and efficient cross-cluster invocations.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/The_Role_of_CloudWeGo_in_Modern_Cloud_Native_Applications/3.png" alt="Image">&lt;/p>
&lt;h3 id="elevating-e-commerce">Elevating E-commerce&lt;/h3>
&lt;p>The e-commerce industry faces high concurrency and performance challenges. When &lt;a href="https://semirshop.com">Semir&lt;/a> opted for Kitex as the RPC framework, they were able to significantly amplify their capacity to manage peak traffic and ensure synchronized order processing. In tandem with &lt;a href="https://istio.io">Istio&lt;/a>, they managed traffic utilizing the Ingress Gateway mesh entry management program and the VirtualService traffic handling logic, thus directing orders to a plethora of services within the mesh.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/The_Role_of_CloudWeGo_in_Modern_Cloud_Native_Applications/4.png" alt="Image">&lt;/p>
&lt;p>The benefits of integrating CloudWeGo were immediately evident:&lt;/p>
&lt;ul>
&lt;li>An improved ability to process a higher number of orders within a given timeframe.&lt;/li>
&lt;li>A shorter processing time even for a specified number of orders, with this performance gap becoming increasingly pronounced as the order volume increased.&lt;/li>
&lt;li>A substantial reduction in machine costs required to support the system.&lt;/li>
&lt;/ul>
&lt;h3 id="ai--machine-learning-implementations">AI &amp;amp; Machine Learning Implementations&lt;/h3>
&lt;p>The AI industry is host to a number of business challenges surrounding machine learning and large-scale model training scenarios. To ensure optimal GPU-related resource utilization and to contend with high costs, a shift from individual GPU clusters for each tenant to multi-tenant shared clusters became necessary. However, existing service infrastructure that was shared between tenants led to mutual performance issues, increased management costs, and a more complex system architecture.&lt;/p>
&lt;p>When it came to AI SaaS companies like &lt;a href="https://intl.ishumei.com/#HOME">NextData&lt;/a>, they embraced cloud-native technologies and Golang for rapid development and iteration, while a three-tiered microservices architecture allowed the access layer to handle user requests through HTTP with high-performance HTTP frameworks like Hertz.&lt;/p>
&lt;p>Upon deploying CloudWeGo, the access layer&amp;rsquo;s RPC client and the logical business layer&amp;rsquo;s RPC server &amp;amp; RPC client underwent refactoring with the Kitex framework, using the Thrift protocol to address limitations of the native Apache Thrift framework. Integration of services like rate limiting, circuit breaking, and overload protection allowed the system to adaptively resolve traffic-related stability issues.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/The_Role_of_CloudWeGo_in_Modern_Cloud_Native_Applications/5.png" alt="Image">&lt;/p>
&lt;p>Through case studies across diverse industries, from gaming to AI, it is evident that CloudWeGo can tackle a myriad of challenges while delivering optimal solutions, reflecting its commitment to versatility, power, and high-standard performance all in equal measure.&lt;/p>
&lt;h1 id="vi-conclusion">VI. Conclusion&lt;/h1>
&lt;p>In the exciting landscape of cloud-native application development, CloudWeGo stands out as a versatile, powerful, and adaptable solution. This post gave an overview of the project, taking us through its introduction, the critical role it plays in the industry, and its unique propositions in the world of cloud-native application development.&lt;/p>
&lt;p>We have looked at how CloudWeGo&amp;rsquo;s emphasis on interoperability, scalability, and performance makes it an outstanding choice for developers. We dug into its various features, including its frameworks and use of OpenTelemetry, providing a robust foundation for modern, cloud-based applications.&lt;/p>
&lt;p>We also unboxed the technical depth of CloudWeGo, examining how RPC like Kitex functions, and presented real-world examples of CloudWeGo implementation across various industries including gaming, financial securities, e-commerce, and AI. Each case deeply demonstrated how embracing CloudWeGo led to improved efficiency, stability, scalability, and a dramatic reduction in operational costs.&lt;/p>
&lt;p>Whether you’re a seasoned developer, a passionate gamer, or an AI enthusiast, CloudWeGo opens up a universe of possibilities, unlocking new avenues for innovation and creativity. Each success story mentioned here is a testament to CloudWeGo&amp;rsquo;s capability. A shared theme across all these cases is how CloudWeGo recognizes industry-specific challenges and addresses them with tailored, innovative solutions.&lt;/p>
&lt;p>There&amp;rsquo;s a world of cloud-native possibilities to explore, and CloudWeGo can be your companion on this journey. Dive into the unique benefits, the seamless experience, and the vast community that CloudWeGo offers. Explore CloudWeGo today and reinvent the way you develop cloud-native applications.&lt;/p></description></item><item><title>Blog: CloudWeGo: A leading practice for building enterprise cloud native middleware!</title><link>https://www.cloudwego.io/blog/2023/06/15/cloudwego-a-leading-practice-for-building-enterprise-cloud-native-middleware/</link><pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/blog/2023/06/15/cloudwego-a-leading-practice-for-building-enterprise-cloud-native-middleware/</guid><description>
&lt;h2 id="cloudwego-overview">CloudWeGo Overview&lt;/h2>
&lt;p>&lt;a href="https://www.cloudwego.io/">CloudWeGo&lt;/a> is a set of microservices middleware developed by ByteDance that can be used to quickly build enterprise-class cloud-native architectures. It is a collection of high-performance, high-extensible, and highly-reliable projects that are focused on microservices communication and governance. It contains many components, including the RPC framework &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>, the HTTP framework &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>, the basic network library Netpoll, inter-process communication library &lt;a href="https://github.com/cloudwego/shmipc-go">shmipc&lt;/a>, Rust-based RPC framework &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> etc.&lt;/p>
&lt;h2 id="cloudwego-background">CloudWeGo Background&lt;/h2>
&lt;p>ByteDance uses Golang as its main development language, and supports the reliable communication of tens of thousands of Golang microservices. With our experience in microservices having undergone a massive traffic, we decided to offer open source software in order to enrich the community’s ecology and launched CloudWeGo in September 2021. CloudWeGo is not only an external open source project, but also a real ultra-large-scale enterprise-level project. We are looking forward to enriching the Golang product system of the cloud native community through CloudWeGo and helping other companies to build cloud-native architectures in a rapid and convenient way. We also hope to attract developers in the open source community, to maintain and improve this project together, provide support for multiple scenarios, and enrich product capabilities. Because the projects under CloudWeGo depend on many internal basic tool libraries, we also open sourced the basic Golang tool libraries used internally, and maintain them in &lt;a href="https://github.com/bytedance/gopkg">bytedance/gopkg&lt;/a>.&lt;/p>
&lt;p>Another language that we are committed to advancing is the Rust language that delivers exceptional performance, safety, and low-level control capabilities. Through our open-source projects and contributions, ByteDance aims to provide developers, enterprises, and Rustaceans with robust support in developing RPC microservices and building cloud-native distributed systems. ByteDance&amp;rsquo;s contribution includes the development of Volo, a lightweight, high-performance, scalable, and user-friendly Rust RPC framework. Leveraging the latest features of Rust, Volo showcases exceptional performance and efficiency. ByteDance has extensively used Volo within its own infrastructure, implementing multiple business and foundational components, surpassing expectations and highlighting its superiority compared to similar solutions written in other languages. Another project is Monoio, a thread-per-core Rust runtime with io_uring/epoll/kqueue. Monoio is designed to offer maximum efficiency and performance by leveraging advanced features of Rust and a unique IO abstraction that minimizes copying. Its inclusion within CloudWeGo ensures robust support for various scenarios and enhances the overall capabilities of the project.&lt;/p>
&lt;p>ByteDance&amp;rsquo;s dedication to Rust extends beyond Volo and Monoio. Through our commitment to simplicity and user-friendly tools, such as the Volo command-line tool, ByteDance actively contributes to lowering the barriers for developers to adopt Rust and leverage its full potential.&lt;/p>
&lt;h2 id="key-features">Key Features&lt;/h2>
&lt;p>Some of the key features of CloudWeGo include:&lt;/p>
&lt;h3 id="high-performance">&lt;strong>High performance&lt;/strong>:&lt;/h3>
&lt;p>Highly performant nature of CloudWeGo projects stems from our implementation of asynchronous RPC, streaming RPC, event-driven programming, and support for protocols like HTTP/2. These design choices and features work together to deliver superior speed, responsiveness, and efficiency, enabling CloudWeGo projects to handle demanding workloads and achieve excellent performance benchmarks.&lt;/p>
&lt;h3 id="high-extensibility">&lt;strong>High extensibility&lt;/strong>:&lt;/h3>
&lt;p>CloudWeGo is designed to allow users to customize and expand its functionality according to their specific requirements. CloudWeGo achieves this by providing a modular or layered design that offers a set of interfaces and default implementation options. By utilizing a modular design, CloudWeGo, as seen in Kitex and Hertz, allows users to extend or inject their own implementations into the framework. This means that developers have the flexibility to tailor the behavior of the framework to suit their needs. They can replace or enhance default implementations with their own custom implementations, enabling them to adapt CloudWeGo to specific use cases or integrate seamlessly with other libraries and tools.&lt;/p>
&lt;h3 id="high-reliability">&lt;strong>High reliability&lt;/strong>:&lt;/h3>
&lt;p>CloudWeGo prioritizes stability and dependability in its projects, providing a reliable framework for developers and enterprises. Through rigorous quality assurance, including code review and testing, potential issues are identified and addressed early on before they impact production environments. CloudWeGo as a whole emphasizes the prevention of any potential losses or disruptions. This is achieved through careful PR integration, extensive testing, and continuous monitoring. CloudWeGo optimizes projects to handle high workloads, ensuring stability and reliability even under heavy load. Feedback from the community helps drive improvements and prompt issue resolution. By adhering to strict quality standards, CloudWeGo projects strive to deliver stable and reliable software.&lt;/p>
&lt;h3 id="microservices-communication-and-governance">&lt;strong>Microservices communication and governance&lt;/strong>:&lt;/h3>
&lt;p>CloudWeGo&amp;rsquo;s Governance feature encompasses service governance modules such as service registry, discovery, load balancing, circuit breaker, rate limiting, retry, monitoring, tracing, logging, and diagnosis. These modules enhance the management, control, and reliability of services within the CloudWeGo framework. They enable dynamic service discovery, load distribution, fault tolerance, performance optimization, and comprehensive monitoring and diagnostics. The Governance feature ensures efficient and reliable service operations in the CloudWeGo ecosystem.&lt;/p>
&lt;p>Here are some of the benefits of using CloudWeGo:&lt;/p>
&lt;ul>
&lt;li>Speed: CloudWeGo offers the ability to accelerate application development by providing a set of pre-built components and libraries. These components and libraries provide essential functionalities, such as networking, database integration, security, and more. They are designed to be easily integrated into applications, reducing the need for building complex functionalities from scratch. With CloudWeGo&amp;rsquo;s speedy development ecosystem, developers can focus on their application&amp;rsquo;s core logic, leverage existing components, and deliver robust solutions in a shorter timeframe. This enables faster time-to-market, increased development efficiency, and ultimately enhances the overall speed of application development.&lt;/li>
&lt;li>Cost savings: By adopting CloudWeGo and its projects such as Kitex, Hertz, Sonic, and others, users can benefit from significant cost savings. This is achieved through reduced CPU and memory consumption compared to older frameworks or similar projects. CloudWeGo&amp;rsquo;s modern framework is designed to be highly optimized and efficient, resulting in minimized software development overhead. Internally at ByteDance, we moved to using the modern high-performance framework that has proven instrumental in saving substantial resources. With CloudWeGo, users can optimize their resource allocation and achieve cost efficiency while leveraging the powerful capabilities and features provided by the framework.&lt;/li>
&lt;li>Security: CloudWeGo prioritizes security, offering a range of features and measures to ensure application security. The framework incorporates secure design principles, implementing industry best practices. It provides built-in authentication and authorization mechanisms for secure user access control. By leveraging the Rust programming language, CloudWeGo benefits from its inherent security advantages, such as strong type safety and memory safety, reducing the risk of common vulnerabilities. The open-source nature of CloudWeGo allows for community contributions and wider security audits, ensuring continuous improvement and prompt vulnerability mitigation. With CloudWeGo, developers can build applications with confidence, knowing that security is prioritized at every level of the framework.&lt;/li>
&lt;/ul>
&lt;h2 id="use-cases">Use Cases&lt;/h2>
&lt;p>CloudWeGo can be used to build a variety of applications, including microservices-based applications, cloud-native applications, real-time applications, IoT applications, and other applications.
Some of the applications include:&lt;/p>
&lt;ul>
&lt;li>Microservices-based applications: CloudWeGo provides a comprehensive set of features for microservices communication and governance, such as service discovery, routing, and orchestration. This makes it easy to build and manage microservices-based applications.&lt;/li>
&lt;li>Cloud-native applications: CloudWeGo is designed to be used in cloud-native environments. It can be used to build applications that are scalable, reliable, and secure.&lt;/li>
&lt;li>Real-time applications: CloudWeGo supports streaming and asynchronous messaging. This makes it a good choice for building real-time applications, such as chat applications and streaming media applications.&lt;/li>
&lt;li>Other applications: CloudWeGo can be used to build a variety of other applications, such as web applications, mobile applications, gaming applications and enterprise applications. Let&amp;rsquo;s explore some of the industry adoption:
&lt;ul>
&lt;li>&lt;strong>Gaming&lt;/strong>: CloudWeGo offers several benefits for the gaming industry. It enables game developers to scale their infrastructure to handle increased player demands, optimize performance, and simplify their business logic through service splitting. With components like current limiting, monitoring, and service registration/discovery, CloudWeGo ensures efficient resource utilization, enhanced responsiveness, and seamless coordination between game components. Additionally, the integration with OpenTelemetry provides valuable monitoring and diagnostics capabilities for developers to optimize their game services and deliver an exceptional gaming experience. Overall, CloudWeGo empowers the gaming industry by providing a scalable, efficient, and streamlined infrastructure for game development and operations.&lt;/li>
&lt;li>&lt;strong>Security&lt;/strong>: In the security industry, CloudWeGo&amp;rsquo;s adoption, specifically through the Kitex framework, brings significant benefits. Organizations can establish observability systems to monitor and analyze the performance of security services. This enables the identification of potential issues and ensures smooth operation. CloudWeGo also offers solutions for service stress testing, allowing organizations to optimize performance and ensure stability during high-load scenarios. Additionally, CloudWeGo addresses challenges related to different connection types within Kubernetes clusters, enabling efficient and secure communication between services. The framework provides specific solutions tailored to the security industry, helping organizations overcome obstacles and optimize their security infrastructure effectively.&lt;/li>
&lt;li>&lt;strong>E-commerce&lt;/strong>: CloudWeGo&amp;rsquo;s Kitex framework offers a powerful solution for e-commerce companies dealing with high-concurrency and high-performance challenges. By integrating Kitex with technologies like Istio, businesses can significantly improve their ability to handle peak traffic and ensure synchronized order processing. This enables efficient communication with multiple e-commerce platforms and prevents issues like overselling. The adoption of CloudWeGo and Kitex, along with the use of a cloud-native service mesh like Istio, enhances the overall performance, scalability, and reliability of e-commerce systems, providing businesses with a competitive edge in the rapidly evolving e-commerce industry.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="getting-started">Getting Started&lt;/h2>
&lt;p>To begin your journey with CloudWeGo projects, you can refer to our &lt;a href="https://www.cloudwego.io/docs/">comprehensive documentation&lt;/a>, which provides step-by-step instructions. Additionally, we regularly publish insightful blogs on various topics, including the latest innovations in &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>, &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>, &lt;a href="https://www.cloudwego.io/blog/2023/04/17/introducing-monoio-a-high-performance-rust-runtime-based-on-io-uring/">Monoio&lt;/a>, &lt;a href="https://github.com/cloudwego/shmipc-go">Shmipc&lt;/a>, and &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a>. We also publish best practices blogs and have a dedicated blog that explores best practices for using &lt;a href="https://www.cncf.io/blog/2023/01/11/kitex-proxyless-practice-traffic-lane-implementation-with-istio-and-opentelemetry/">Kitex without a proxy&lt;/a>. These resources serve as valuable references to help you make the most of CloudWeGo&amp;rsquo;s offerings and stay up-to-date with the latest developments in the ecosystem.&lt;/p>
&lt;h2 id="contributing">Contributing&lt;/h2>
&lt;p>The CloudWeGo project is subdivided into subprojects under:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> (Kitex &amp;amp; Kitex ecosystem &amp;amp; kitex-contrib)&lt;/li>
&lt;li>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> (Hertz &amp;amp; Hertz ecosystem &amp;amp; hertz-contrib)&lt;/li>
&lt;li>&lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> (Netpoll &amp;amp; Netpoll ecosystem)&lt;/li>
&lt;li>&lt;a href="https://github.com/cloudwego/shmipc-go">Shmipc&lt;/a> (shmipc-spec &amp;amp; shmipc-go)&lt;/li>
&lt;li>&lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> (Volo &amp;amp; Volo ecosystem &amp;amp; volo-rs &amp;amp; Motore &amp;amp; Pilota)&lt;/li>
&lt;li>&lt;a href="https://github.com/cloudwego/community">Website &amp;amp; Docs&lt;/a> (cloudwego.github.io &amp;amp; community)&lt;/li>
&lt;/ul>
&lt;p>Kitex is equipped with built-in governance strategies and expansion interfaces for frictionless integration into the microservice system. Hertz is a Go HTTP framework with high-performance and strong-extensibility for building micro-services. Netpoll is aimed at scenarios that demand high performance on RPC scenarios. Shmipc is a high performance inter-process communication library, built on Linux&amp;rsquo;s shared memory technology and uses unix or tcp connection to do process synchronization and finally implements zero copy communication across inter-processes. Volo is a high-performance and strong-extensibility Rust RPC framework that helps developers build microservices. Each component of CloudWeGo can be used separately.&lt;/p>
&lt;p>We welcome you to &lt;a href="https://github.com/cloudwego/community/blob/main/CONTRIBUTING.md">contribute&lt;/a> by submitting issues and PRs to build CloudWeGo together. Contributing to CloudWeGo involves various roles and responsibilities within the project&amp;rsquo;s GitHub organization. The roles include Member, Committer, Reviewer, Approver, and Maintainer. Members are active contributors in the community and are expected to participate in discussions and make multiple contributions to the project. Committers are active code contributors and play a role in reviewing and approving code contributions. Reviewers have expertise in the codebase and provide feedback on contributions. Approvers review and approve code contributions, ensuring their holistic acceptance. Maintainers are responsible for setting technical direction, making design decisions, and ensuring the overall health of a subproject. The responsibilities and privileges of each role vary, but they all contribute to the growth and success of CloudWeGo. The responsibilities of contributor roles in CloudWeGo are outlined in our &lt;a href="https://github.com/cloudwego/community/blob/main/COMMUNITY_MEMBERSHIP.md">community membership document&lt;/a>.&lt;/p>
&lt;p>We are excited for more developers to join, and also look forward to CloudWeGo helping more and more companies quickly build cloud-native architectures. Feel free to raise an issue in &lt;a href="https://github.com/cloudwego">Github&lt;/a> if you have any questions. Furthermore, you can join our &lt;a href="https://discord.gg/jceZSE7DsW">Discord&lt;/a> to keep updated with the latest news.&lt;/p>
&lt;h2 id="community-and-support">Community and Support&lt;/h2>
&lt;p>At ByteDance, we try to make the projects friendly to external users, and our internal projects will also use this open source project as a library for iterative development. CloudWeGo follows a key principle of maintaining one set of code internally and externally, iterating them as a whole. It has been gratifying to see Kitex gain 6000 stars, Hertz gain 3800+ stars and Netpoll gain 3600+ stars since its launch. More about all these projects can be found under our &lt;a href="https://github.com/cloudwego">cloudwego github repository&lt;/a>.&lt;/p>
&lt;h3 id="maintenance">Maintenance&lt;/h3>
&lt;p>A complete microservice system builds upon a basic cloud ecosystem. No matter how the microservices are developed; based on the public cloud, a private cloud or your own infrastructure, additional services (including service governance platform, monitoring, tracing, service registry and discovery, configuration and service mesh etc) and some customized standards are needed to provide better service governance. At Bytedance, we have complete internal services to support the microservice system, but these services can not be open sourced in the short term. So, how will CloudWeGo maintain a set of codes internally and externally, and iterate them as a whole?&lt;/p>
&lt;p>Projects in CloudWeGo are not coupled with internal ecosystem. For example, Netpoll is directly migrated to open source libraries, and our internal dependencies are adjusted to open source libraries. Kitex’s code is split into two parts, including the core of Kitex which has been migrated to the open source library, and the encapsulated internal library which will provide transparent upgrades for internal users. For open source users who use Kitex, they can also extend Kitex and integrate Kitex into their own microservice system. We hope, and expect, that more developers will contribute their own extensions to &lt;a href="https://github.com/kitex-contrib">kitex-contrib&lt;/a>, &lt;a href="https://github.com/hertz-contrib">hertz-contrib&lt;/a> and &lt;a href="https://github.com/volo-rs">volo-rs&lt;/a> providing help and convenience for more users.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>CloudWeGo is a rapidly growing project with a large and active community. It is a great choice for developers who are looking to build enterprise-class cloud native applications. If you are looking for a high-performance, extensible, and reliable middleware solution for your cloud native applications, then CloudWeGo is a great choice.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/logo.png" alt="image">&lt;/p></description></item><item><title>Blog: An Article to Learn About ByteDance Microservices Middleware CloudWeGo</title><link>https://www.cloudwego.io/blog/2022/03/25/an-article-to-learn-about-bytedance-microservices-middleware-cloudwego/</link><pubDate>Fri, 25 Mar 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/blog/2022/03/25/an-article-to-learn-about-bytedance-microservices-middleware-cloudwego/</guid><description>
&lt;p>In the cloud native era, infrastructures across all industries are undergoing a microservice architecture transformation, and all internet companies are concerned about R&amp;amp;D efficiency and stability.
Developers who want to build microservices can never forgo supporting microservice governance, such as governance platforms, monitoring, tracing, registration/discovery, configuration centers, service mesh, etc.
With Golang gradually becoming the dominating programming language in the cloud native era, there is a strong demand for Golang-based microservices middleware in the open source community.&lt;/p>
&lt;p>ByteDance also faces these problems. In 2014, ByteDance introduced Golang to solve the high concurrency problem faced by push services with persistent connections;
and two years later, the technical team launched a framework called Kite based on Golang, and rolled out Ginex after lightly encapsulating the open-source project Gin.
In QCon 2021, Guozhu Cheng, the head of ByteDance&amp;rsquo;s infrastructure/service framework team, said that the launch of these two original frameworks has greatly promoted Golang&amp;rsquo;s adoption within the company.&lt;/p>
&lt;p>However, due to evolutions of related technologies and demanding business requirements, the deeply coupled Kite and Thrift are difficult to be transformed and improved on the network model or codec level,
and therefore continuous feature delivery will inevitably cause code bloat and blocked iterations. In the second half of 2019, the ByteDance technical team began to redesign the Golang RPC framework.
At the same time, in order to get better performance in network communication, support connection multiplexing and sense connection status, they developed their own network library &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>.&lt;/p>
&lt;p>ByteDance refactored Kite as &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>, designed revolving around performance and scalability, and released it in October 2020 for internal use.
As of September 2021, there are 30, 000+ online microservices using &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>, most of which can benefit from boosted CPU and alleviated latency after using the new framework.&lt;/p>
&lt;p>&amp;ldquo;After &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> became widely used within ByteDance, we decided to gradually entail our practice open-source revolving around microservices and keep it in line with the outside.&amp;rdquo;
ByteDance CloudWeGo technical experts said, &amp;ldquo;But there are many microservice-related projects, and each project is open-source alone, which is not friendly to external users.
So we named the project as CloudWeGo and gradually enabled the entire internal microservice system to be open-source, using open-source libraries internally and externally. Each project iterates mainly with open-source libraries.&amp;rdquo;&lt;/p>
&lt;p>On September 8, 2021, ByteDance officially announced the open source CloudWeGo.&lt;/p>
&lt;h2 id="cloudwego">CloudWeGo&lt;/h2>
&lt;p>CloudWeGo is a set of microservice middleware developed by ByteDance with high performance, strong scalability and stability.
It focuses on microservice communication and governance, and meets the demands of different businesses in various scenarios.
CloudWeGo also focuses on integration with the cloud native ecology, supporting K8s registry, Prometheus, and OpenTracing.&lt;/p>
&lt;p>CloudWeGo currently has 4 repositories: &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>, &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>, Thriftgo and netpoll-http2, featuring the RPC framework – Kitex and the network library – Netpoll.
&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> is equipped with built-in governance strategies and expansion interfaces for frictionless integrations into the microservice system. &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> is aimed at scenarios where demand high performance.&lt;/p>
&lt;p>Each component of CloudWeGo can be used separately. &amp;ldquo;Many people worry that &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> would be a heavy-weight framework. In fact, &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> does not couple any other component including &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>.
Users can also optionally integrate some of Kitex&amp;rsquo;s built-in governance functions. &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> is a network library that can work separately with other RPC frameworks and HTTP frameworks.
Thriftgo is a Thrift IDL parser and code generator. It is also a stand-alone tool and provides a customizable, plug-in mechanism for the code generation.&amp;rdquo;
ByteDance CloudWeGo technical experts said, &amp;ldquo;We will continue to move all other internal projects to the open-source track, such as HTTP framework Hertz, shared memory-based IPC communication library ShmIPC, etc., to provide microservices support for wider scenarios.&amp;rdquo;&lt;/p>
&lt;h2 id="advantages--disadvantages">Advantages &amp;amp; Disadvantages&lt;/h2>
&lt;p>The close connection between microservice middleware and business is the foundation of the entire business architecture; so the selection of technology requires special care. Our selection criteria mainly depend on two aspects：&lt;/p>
&lt;ul>
&lt;li>It can address practical business problems and is ready for production with massive traffic, and is easy to use, governable, mature and stable.&lt;/li>
&lt;li>The technology is open-source; and the number of Stars, project activity (Issues &amp;amp; PRs), document update frequency, and release cycle of the open-source project are stable and reliable.&lt;/li>
&lt;/ul>
&lt;p>The advantage of CloudWeGo is that it has already been tested with massive traffic amid the real production deployment in ByteDance. Providing a practical example that can be referred to attest for its stability and reliability.
&amp;ldquo;One of the characteristics of CloudWeGo is high performance, but at the beginning of the development, we often confront performance bottlenecks. So we improved network library and Thrift serialization specifically.
The optimization process was prolonged, with a bottleneck taking a long time to test and fine-tune repetitively. We have also published two articles &amp;ldquo;ByteDance Go RPC Framework Kitex Performance Optimization Practice&amp;rdquo;
and &amp;ldquo;ByteDance on the Go Network Library Practice&amp;rdquo; to share our optimization practices.&amp;rdquo; ByteDance CloudWeGo technical experts said.&lt;/p>
&lt;p>Compared to similar projects, the CloudWeGo R&amp;amp;D team considered not only its performance and strong scalability, but also ease of use. &amp;ldquo;Taking &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> as an example, it is currently inferior to some open-source frameworks in terms of the diversity of governance functions.
But from the perspective of performance, scalability, and user experience, &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> showcases the following advantages. &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> supports a variety of protocols, because it mainly applies Thrift. Kitex has also made performance improvements for Thrift support.
If using Thrift, &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> will be the best choice.&amp;rdquo; ByteDance CloudWeGo technical experts remark on the benefits of using CloudWeGo.&lt;/p>
&lt;p>In addition, in order to uphold a key principle of maintaining one set of code internally and externally, iterating them as a whole,
ByteDance has directly migrated projects without coupling the internal ecology to the CloudWeGo open-source library, and adapt the internal dependency for the open-source library.
For &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>, which requires integrated governance functions into the microservice system, the open-source team split the internal and external code, migrating Kitex&amp;rsquo;s core code to the open source library.
The internal library encapsulates a shell to ensure that updates are transparent to users. And the modules that integrate internal governance features are retained in the internal library as extensions of &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>.
In the future, ByteDance will continue to migrate new features that have been internally validated for stability to open-source libraries.&lt;/p>
&lt;p>Inside ByteDance, in order to facilitate Kitex&amp;rsquo;s integration into the internal governance system, &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> provides a Byted Suite extension, integrating the internal registry, configuration center, monitoring, etc.
Internal Service Mesh has been implemented on a large scale. &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> determines whether it is a Service Mesh mode based on the information of the service, if so, &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> will uninstall the governance components, and the governance functions will sink into Service Mesh.
As an attempt to speed up the performance of communication with Service Mesh, &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> separately extends the TransHandler module to integrate the self-developed ShmIPC, and communicates with Service Mesh through ShmIPC.
Subsequently, Kitex&amp;rsquo;s extension to ShmIPC and the ShmIPC library will also be open-source.&lt;/p>
&lt;p>However, CloudWeGo has its own limitations. ByteDance CloudWeGo technical experts told InfoQ: The richness and diversity of CloudWeGo functions are not enough, pending further improvement.
ByteDance&amp;rsquo;s technical team will solicit the needs of external users, provide support, and welcome more developers to contribute. At present, the performance advantages of Kitex Server are obvious, but the performance of the Client side with Server, and we will focus on improving the Client in the future.
The primary goal is to make default scenarios compatible with each other, with negligible performance overhead. &amp;ldquo;The launch of the open source has attracted public attention, and we observed some stress test comparisons showing that &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> performance was mediocre,
mainly because the stress test scenario was not aligned. We will consider providing better performance strategies for the open-source community.&amp;rdquo;&lt;/p>
&lt;h2 id="open-source-is-not-about-completing-kpis">Open Source is Not About Completing KPIs&lt;/h2>
&lt;p>At present, CloudWeGo is dynamic in the community. Before the official announcement of open source, &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> gained 1.2k stars and &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> gathered 700+ stars within one month.
After ByteDance officially announced the open source CloudWeGo on September 8, as of early October, the overall number of stars in the project has exceeded 4,800 and has been included in the CNCF landscape.
The overall star number of the project has exceeded 4800, and it has been included in the CNCF landscape.&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/article_to_learn_about_CloudWeGo/image.png" alt="image">&lt;/p>
&lt;p>ByteDance CloudWeGo technical experts said, &amp;ldquo;We have received a lot of feedback from the community. For example, many users call for Protobuf.
In response to this feedback, we plan to implement &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> performance optimizations for Protobuf support. We welcome you to submit issues and PRs to CloudWeGo.
We&amp;rsquo;ve also set up customized support for enterprises and organizations to use &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> and &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>, and hope that CloudWeGo will truly become a universal, available open-source solution to microservices communication and governance in the future.&amp;rdquo;&lt;/p>
&lt;p>Regarding &amp;ldquo;open source&amp;rdquo;, ByteDance CloudWeGo technology experts have a clear vision: &amp;ldquo;Completing KPIs is not the purpose of this open source project.&amp;rdquo;
A healthy open-source model focuses on open sharing, co-growth, and long-termism. CloudWeGo recognizes individual participation, community values, and the sense of belonging brought by open source community.&amp;quot;&lt;/p>
&lt;p>&amp;ldquo;As a beneficiary and participant of the open source project, ByteDance also hopes to become a promoter and leader of the open source project.
It hopes to gift excellent internal practices to the open source community, build and enrich the open source ecosystem in the infrastructure field together with the community,
and provide wider and better choices for developers and enterprises for their technology selection.&amp;rdquo; ByteDance CloudWeGo technology experts said,
&amp;ldquo;We embrace the open source culture, listen to community feedback, actively meet user&amp;rsquo;s needs, provide Chinese and English documentations, and develop guidelines quickly, to facilitate and support community developers to understand CloudWeGo and participate in contributions.&amp;rdquo;&lt;/p>
&lt;p>&lt;strong>Project address:&lt;/strong> &lt;a href="https://github.com/cloudwego">https://github.com/cloudwego&lt;/a>&lt;/p>
&lt;p>&lt;strong>Interviewees:&lt;/strong> ByteDance CloudWeGo technical experts (Guangming Luo, Rui Yang, Ziang Ma).&lt;/p>
&lt;p>&lt;strong>Reference link:&lt;/strong> &lt;a href="https://www.infoq.cn/article/9ixlu4kjapg3ufhymm3j">https://www.infoq.cn/article/9ixlu4kjapg3ufhymm3j&lt;/a>&lt;/p></description></item><item><title>Blog: CloudWeGo Open Source Announcement</title><link>https://www.cloudwego.io/blog/2021/09/13/cloudwego-open-source-announcement/</link><pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/blog/2021/09/13/cloudwego-open-source-announcement/</guid><description>
&lt;h2 id="background">Background&lt;/h2>
&lt;p>ByteDance is proud to announce the launch of open source software &lt;a href="https://github.com/cloudwego">CloudWeGo&lt;/a>. Focusing on microservice communication and governance, it offers high performance, strong extensibility, and high reliability which enables quick construction of an enterprise-level cloud native architecture.&lt;/p>
&lt;p>ByteDance uses Golang as its main development language, and supports the reliable communication of tens of thousands of Golang microservices. We are experienced in microservices after practicing under massive traffic, and so we decided to offer open source software in order to enrich the community&amp;rsquo;s ecology.&lt;/p>
&lt;p>We have built the CloudWeGo project to gradually open source the internal microservices system and try to make the projects friendly to external users, and our internal projects will also use this open source project as a library for iterative development. CloudWeGo will follow a key principle of maintaining one set of code internally and externally, iterating them as a whole. As we needed to migrate our internal users to open source libraries transparently, we did not initially pursue any publicity. However, it has been gratifying to see Kitex gain 1.2k stars and Netpoll gain 700+ stars within one month organically.&lt;/p>
&lt;p>CloudWeGo is not only an external open source project, but also a real ultra-large-scale enterprise-level practice project.&lt;/p>
&lt;p>We look forward to enriching the Golang product system of the cloud native community through CloudWeGo and helping other companies to build cloud-native architectures in a rapid and convenient way. We also hope to attract developers in the open source community, to maintain and improve this project together, provide support for multiple scenarios, and enrich product capabilities.&lt;/p>
&lt;p>Because the projects under CloudWeGo depend on many internal basic tool libraries, we also open source the basic Golang tool libraries used internally, and maintain them in &lt;a href="https://github.com/bytedance/gopkg">bytedance/gopkg&lt;/a>.&lt;/p>
&lt;h2 id="cloudwego">CloudWeGo&lt;/h2>
&lt;p>To begin with, the two main projects included within CloudWeGo are the &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> RPC framework and the &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> network library. We chose not to publicise these projects prematurely, to ensure our open source technologies were ready and had sufficient verification upon launch.&lt;/p>
&lt;h3 id="kitex">Kitex&lt;/h3>
&lt;p>Kitex [kaɪt&amp;rsquo;eks] is a &lt;strong>high-performance&lt;/strong> and &lt;strong>strong-extensibility&lt;/strong> Golang RPC framework used in Bytedance. Before Kitex, the internal Golang framework was Kite, which was strongly coupled with Thrift - the code generation part of which covered intricate logic in the code.&lt;/p>
&lt;p>Due to these factors, it was difficult to optimize the framework from the network model or codec level.&lt;/p>
&lt;p>Adding new features will inevitably lead to more bloated code and would have hindered the iteration process. Instead we designed a new framework, Kitex, to address these concerns. Although Kitex is a new framework, it has been applied online internally for more than a year. At present, more than 50% of Golang microservices in Bytedance use Kitex.&lt;/p>
&lt;p>Features of Kitex include:&lt;/p>
&lt;ul>
&lt;li>High Performance&lt;/li>
&lt;/ul>
&lt;p>Kitex integrates Netpoll, a high-performance network library which offers significant performance advantage over &lt;a href="https://pkg.go.dev/net">go net&lt;/a>. Kitex also makes some optimizations on the codec of Thrift, details of which can be found &lt;a href="https://mp.weixin.qq.com/s/Xoaoiotl7ZQoG2iXo9_DWg">here&lt;/a>. Users can also refer to this &lt;a href="https://github.com/cloudwego/kitex-benchmark">website&lt;/a> for performance results.&lt;/p>
&lt;ul>
&lt;li>Extensibility&lt;/li>
&lt;/ul>
&lt;p>Kitex employs a modular design and provides many interfaces with default implementation for users to customize. Users can then extend or inject them into Kitex to fulfill their needs. Please refer to the official &lt;a href="https://www.cloudwego.io/docs/kitex/tutorials/framework-exten/">doc&lt;/a> for the extensibility of Kitex. For their network library, developers can freely choose other network libraries aside from netpoll.&lt;/p>
&lt;ul>
&lt;li>Multi-message Protocol&lt;/li>
&lt;/ul>
&lt;p>Regarding the RPC message protocol, Kitex supports &lt;strong>Thrift&lt;/strong>, &lt;strong>Kitex Protobuf&lt;/strong> and &lt;strong>gRPC&lt;/strong> by default. For Thrift, it supports two binary protocols, Buffered and Framed. Kitex Protobuf is a Kitex custom Protobuf messaging protocol with a protocol format similar to Thrift. The gRPC message protocol enables Kitex to interact with gRPC. Additionally, Kitex allows developers to extend their own messaging protocols.&lt;/p>
&lt;ul>
&lt;li>Multi-transport Protocol&lt;/li>
&lt;/ul>
&lt;p>The transport protocol encapsulates the message protocol for RPC communication and is able to transparently transmit meta-information used for service governance. Kitex supports two transport protocols, &lt;strong>TTHeader&lt;/strong> and &lt;strong>HTTP2&lt;/strong>. TTHeader can be used in conjunction with Thrift and Kitex Protobuf. At present, HTTP2 is mainly used in combination with the gRPC protocol, and will support Thrift in the future.&lt;/p>
&lt;ul>
&lt;li>Multi-message Type&lt;/li>
&lt;/ul>
&lt;p>Kitex supports &lt;strong>PingPong&lt;/strong>, &lt;strong>One-way&lt;/strong>, and &lt;strong>Bidirectional Streaming&lt;/strong>. Among them, One-way currently only supports Thrift protocol, two-way Streaming only supports gRPC, and Kitex will support Thrift&amp;rsquo;s two-way Streaming in the future.&lt;/p>
&lt;ul>
&lt;li>Service Governance&lt;/li>
&lt;/ul>
&lt;p>Kitex integrates service governance modules such as service registry, service discovery, load balancing, circuit breaker, rate limiting, retry, monitoring, tracing, logging, diagnosis, etc. Most of these modules have been provided with default extensions, and users can make their choice of modules to integrate.&lt;/p>
&lt;ul>
&lt;li>Code Generation&lt;/li>
&lt;/ul>
&lt;p>Kitex has built-in code generation tools that support generating &lt;strong>Thrift&lt;/strong>, &lt;strong>Protobuf&lt;/strong>, and scaffold code. The original Thrift code is generated by Thriftgo, which is now open sourced. Kitex&amp;rsquo;s optimization of Thrift is supported by Kitex Tool as a plugin. Protobuf code is generated by Kitex as an official protoc plugin. Currently, Protobuf IDL parsing and code generation are not separately supported.&lt;/p>
&lt;h3 id="netpoll">Netpoll&lt;/h3>
&lt;p>Netpoll is a high-performance, non-blocking I/O networking framework which focuses on RPC scenarios, developed by ByteDance.&lt;/p>
&lt;p>RPC is usually heavy on processing logic, including business logic and codec, and therefore cannot handle I/O serially like Redis. However, Go&amp;rsquo;s standard library &lt;a href="https://github.com/golang/go/tree/master/src/net">net&lt;/a> is designed for blocking I/O APIs, so that the RPC framework can only follow the One Conn One Goroutine design. It increases cost for context switching due to a large number of goroutines under high concurrency. Moreover, &lt;a href="https://github.com/golang/go/blob/master/src/net/net.go">net.Conn&lt;/a> has no API to check Alive, so it is difficult to make an efficient connection pool for the RPC framework, because there may be a large number of failed connections in the pool.&lt;/p>
&lt;p>On the other hand, the open source community currently lacks Go network libraries that focus on RPC scenarios. Similar repositories such as evio and gnet are focused on scenarios like Redis and Haproxy.&lt;/p>
&lt;p>Netpoll has been designed to solve these problems. It draws inspiration from the design of &lt;a href="https://github.com/tidwall/evio">evio&lt;/a> and &lt;a href="https://github.com/netty/netty">netty&lt;/a>, achieves excellent &lt;a href="https://github.com/cloudwego/netpoll#performance">performance&lt;/a> and is more suitable for microservice architecture. Netpoll also provides a number of &lt;a href="https://github.com/cloudwego/netpoll#features">Features&lt;/a>. Developers are recommended to use Netpoll as the network library of the RPC framework.&lt;/p>
&lt;h3 id="thriftgo">Thriftgo&lt;/h3>
&lt;p>Thriftgo is an implementation of &lt;a href="https://thrift.apache.org/docs/idl">thrift&lt;/a> compiler in go language that supports complete syntax and semantic checking of Thrift IDL.&lt;/p>
&lt;p>Compared with the official Golang code generation by Apache Thrift, Thriftgo made some bug fixes and supports a plugin mechanism. Users can customize the generated code according to their needs.&lt;/p>
&lt;p>Thriftgo is the code generation tool of Kitex. CloudWeGo will soon opensource &lt;strong>thrift-gen-validator&lt;/strong>, a plugin of Thriftgo that supports IDL Validator and is used for field verification, which is not provide by Thrift. With the IDL Validator, developers do not need to implement code verification logic by themselves.&lt;/p>
&lt;p>Although Thriftgo currently only supports the generation of Golang Thrift code, it is positioned to support Thrift code generation in various languages. If there is a need in future, we will also consider supporting code generation for other programming languages. At the same time, we will try to contribute Thriftgo to the Apache Thrift community.&lt;/p>
&lt;h2 id="maintenance">Maintenance&lt;/h2>
&lt;p>A complete microservice system builds upon a basic cloud ecosystem. No matter how the microservices are developed; based on the public cloud, a private cloud or your own infrastructure, additional services (including service governance platform, monitoring, tracing, service registry and discovery, configuration and service mesh etc) and some customized standards are needed to provide better service governance. At Bytedance we have complete internal services to support the microservice system, but these services cannot be open source in the short term. So, how will CloudWeGo maintain a set of code internally and externally, and iterate them as a whole?&lt;/p>
&lt;p>Projects in CloudWeGo are not coupled with the internal ecology. For example, Netpoll is directly migrated to open source libraries, and our internal dependencies are adjusted to open source libraries.&lt;/p>
&lt;p>Kitex&amp;rsquo;s code is split into two parts, including the core of Kitex which has been migrated to the open source library, and the encapsulated internal library which will provide transparent upgrades for internal users.&lt;/p>
&lt;p>For open source users who use Kitex, they can also extend Kitex and integrate Kitex into their own microservice system. We hope, and expect, that more developers will contribute their own extensions to &lt;a href="https://github.com/kitex-contrib">kitex-contrib&lt;/a>, providing help and convenience for more users.&lt;/p>
&lt;h2 id="future-directions">Future directions&lt;/h2>
&lt;ul>
&lt;li>Open source other internal projects&lt;/li>
&lt;/ul>
&lt;p>We will continue to open source other internal projects, such as HTTP framework &lt;strong>Hertz&lt;/strong>, shared memory-based IPC communication library &lt;strong>ShmIPC&lt;/strong> and others, to provide more support for microservice scenarios.&lt;/p>
&lt;ul>
&lt;li>Open source verified and stable features&lt;/li>
&lt;/ul>
&lt;p>The main projects of CloudWeGo provide support for internal microservices of Bytedance. New features are usually verified internally, and we will gradually open source them when they are relatively mature, such as the integration of &lt;strong>ShmIPC&lt;/strong>, &lt;strong>no serialization&lt;/strong>, and &lt;strong>no code generation&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>Combine internal and external needs and iterate&lt;/li>
&lt;/ul>
&lt;p>After launching open source software, in addition to supporting internal users we also hope that CloudWeGo can provide good support for external users and help everyone quickly build their own microservice system. As such, we will iterate based on the needs of both internal and external users.&lt;/p>
&lt;p>Following initial feedback, users have shown a stronger demand for Protobuf. Although Kitex supports multiple protocols, the internal RPC communication protocol of Bytedance is Thrift. Protobuf, Kitex Protobuf or compatibility with gRPC is supported only to fulfill the needs of a small number of internal users, so performance [for Protobuf] has not been optimized yet. In terms of code generation, we have not made any optimizations, and currently utilize Protobuf&amp;rsquo;s official binary directly.&lt;/p>
&lt;p>Gogo/protobuf is an excellent open source library that optimizes Protobuf serialization performance based on generated code, but unfortunately the library is currently out of maintenance, which is why Kitex did not choose gogo.
In order to meet the growing needs of developers, we are planning to carry out Kitex&amp;rsquo;s performance optimization for Protobuf support.&lt;/p>
&lt;p>You are welcome to submit issues and PRs to build CloudWeGo together. We are excited for more developers to join, and also look forward to CloudWeGo helping more and more companies quickly build cloud-native architectures. If any corporate customers want to employ CloudWeGo in your internal projects, we can provide technical support. Feel free to raise an issue in &lt;a href="https://github.com/cloudwego">Github&lt;/a> if you have any questions.&lt;/p></description></item></channel></rss>